{"componentChunkName":"component---src-templates-blog-post-js","path":"/singleton-pattern/","webpackCompilationHash":"3237468b0c27b1c362d5","result":{"data":{"site":{"siteMetadata":{"title":"云音乐大前端专栏","author":"云音乐大前端团队","siteUrl":"https://musicfe.dev"}},"markdownRemark":{"id":"0885328f-4f15-5e23-b749-4484da315f16","excerpt":"header.png 图片来源：https://kalianey.com/ 本文作者：郑正和（https://github.com/proempire） 本文以音频能力中的全局播放为切入点，探讨单例模式在前端业务中的应用。文中代码均为 React…","html":"<p><img src=\"https://kalianey.com/wp-content/uploads/2016/03/singleton_pattern.jpg\" alt=\"header.png\"></p>\n<blockquote>\n<p>图片来源：<a href=\"https://kalianey.com/\">https://kalianey.com/</a></p>\n</blockquote>\n<blockquote>\n<p>本文作者：郑正和（<a href=\"https://github.com/proempire%EF%BC%89\">https://github.com/proempire）</a></p>\n</blockquote>\n<p>本文以音频能力中的全局播放为切入点，探讨单例模式在前端业务中的应用。文中代码均为 React 组件内代码。</p>\n<h2>全局播放</h2>\n<p>在文章一开始，我们先解释一下<b>全局播放</b>的含义：</p>\n<ol>\n<li>媒体在应用中时时都在播放（跨路由、跨 tab、后台播放）</li>\n<li>用户对媒体有全局控制能力</li>\n</ol>\n<p>对大多数具备音频能力的应用而言，为了保证音频体验上的流畅，全局播放基本是一项必备的能力，很难想象使用一个不具备全局播放能力的应用是种什么样的体验。设想一下，你在听一首歌的同时不能去浏览其他内容？显然这是不可接受的。在当前这个时代，即便是视频，部分应用也已经支持了全局播放（Youtube）。</p>\n<p>那么对于前端而言，全局播放又是一个什么样的存在呢？虽然前端领域的音视频能力起步时间较晚，但是当前大量的 Hybrid APP、小程序，或是稍微复杂一些的活动页，都对全局播放提出了较高的要求，列表增删，播放模式切换、切歌等等能力都常常被包含在内。</p>\n<p>我们知道，前端里的 Audio 对象已经支持了一部分音频能力，如自动播放、循环、静音等能力，但这里有个问题：前端应用在进行全局播放时，无论当前处于单页应用（只能是单页应用，多页应用暂时不可能做出全局播放）的哪个子页面，都必须<b>能且仅能操作同一个</b>音频对象，否则就不是全局播放了。</p>\n<p>因此，我们有必要对 Audio 做一层封装，以提供全局播放相关能力，以下代码对<b>能且仅能操作同一个</b>这一逻辑进行了封装：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> singletonAudio <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">Audio</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">options</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>options<span class=\"token punctuation\">.</span>src<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'播放地址不允许为空'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>audioNode <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'audio'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>audioNode<span class=\"token punctuation\">.</span>src <span class=\"token operator\">=</span> options<span class=\"token punctuation\">.</span>src<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>audioNode<span class=\"token punctuation\">.</span>preload <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span>options<span class=\"token punctuation\">.</span>preload<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>audioNode<span class=\"token punctuation\">.</span>autoplay <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span>options<span class=\"token punctuation\">.</span>autoplay<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>audioNode<span class=\"token punctuation\">.</span>loop <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span>options<span class=\"token punctuation\">.</span>loop<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>audioNode<span class=\"token punctuation\">.</span>muted <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span>options<span class=\"token punctuation\">.</span>muted<span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\">// ...</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token function\">play</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">playOptions</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// ...</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// 其他对单个音频的控制逻辑...</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">let</span> audio<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">const</span> _static <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">options</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// 若 audio 实例还未被创建，则创建并返回</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>audio <span class=\"token operator\">===</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                audio <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Audio</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token keyword\">return</span> audio<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> _static<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">Audio</code> 类的具体控制逻辑已被省去，因为这不是我们的重点。这里我们采用了一个 IIFE（立即执行函数）来构造闭包，仅返回了一个 <code class=\"language-text\">_static</code> 对象，该对象提供了 <code class=\"language-text\">getInstance</code> 方法，封装了<b>创建</b>和<b>获取</b>的步骤，由此，使用者无论何时、在应用何处调用该方法，都会获取到唯一一个音频实例，对其进行操作，就可以完成全局播放的逻辑。</p>\n<h2>单例模式（Singleton Pattern）</h2>\n<p>在上面的全局播放例子中，我们可以注意到音频实例并没有直接暴露给使用者，而是通过一个公有方法 <code class=\"language-text\">getInstance</code> 让使用者创建、获取音频实例。这么做的目的是禁止使用者主动实例化 <code class=\"language-text\">Audio</code>，在公共组件的层面上保证全局只存在一个 <code class=\"language-text\">audio</code> 实例。</p>\n<p>现在我们可以来看看单例模式的定义了：</p>\n<blockquote>\n<p>类仅允许有一个实例，且该实例在用户侧有一个访问点。</p>\n</blockquote>\n<p>在我们全局播放的例子中，始终只操作一个 <code class=\"language-text\">audio</code> 实例，且该实例全局可用。</p>\n<p>单例模式的一个常见应用场景（applicability）如下：</p>\n<blockquote>\n<p>实例必须能通过子类的形式进行扩展，且用户侧能在不修改代码的前提下使用该扩展实例。</p>\n</blockquote>\n<p>光看概念毕竟有点抽象，我们还是以实际的场景来说明一下。</p>\n<p>仍以上文的 <code class=\"language-text\">Audio</code> 类为例，假设单例现在需要提供一个永远保持循环播放的子类 <code class=\"language-text\">LoopAudio</code>，代码修改如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> singletonAudio <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">Audio</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 同上文...</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">LoopAudio</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Audio</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">options</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>audioNode<span class=\"token punctuation\">.</span>loop <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// 其他对单个音频的控制逻辑，不开放 loop 属性的控制方法...</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">let</span> audio<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">const</span> _static <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">options</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// 若 audio 实例还未被创建，则创建并返回</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>audio <span class=\"token operator\">===</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isLoop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    audio <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LoopAudio</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                    audio <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Audio</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token keyword\">return</span> audio<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> _static<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">LoopAudio</code> 类继承自 <code class=\"language-text\">Audio</code> 类，强制定义了 <code class=\"language-text\">loop</code> 属性，且封闭了 <code class=\"language-text\">loop</code> 属性的修改途径（若 <code class=\"language-text\">Audio</code> 类已经提供，在 <code class=\"language-text\">LoopAudio</code> 的同名方法中取消这一行为）。同时在返回的 <code class=\"language-text\">_static</code> 对象中，我们通过 <code class=\"language-text\">isloop</code> 方法判断要返回给用户侧哪种实例，注意这里的判断只有第一次会进行，一旦实例创建，就不能再更改了。</p>\n<p>你可能要问，为什么搞这么麻烦？我在 <code class=\"language-text\">_static</code> 里重新定义一个方法 <code class=\"language-text\">getLoopInstance</code> 直接创建/获取 <code class=\"language-text\">LoopAudio</code> 类不行吗？如果你这么想，请回头再仔细看看单例模式应用场景的第 2 点后半句，<b>用户侧不修改代码</b>，即用户侧对 <code class=\"language-text\">audio</code> 实例扩展为 <code class=\"language-text\">loopAudio</code> 实例是无感知的。如果你非要说：我在业务组件里有些时候需要用 <code class=\"language-text\">audio</code> 实例，有些时候需要用 <code class=\"language-text\">loopAudio</code> 实例，那么，你完全可以在业务代码里自己对 <code class=\"language-text\">audio</code> 实例的 <code class=\"language-text\">loop</code> 属性进行控制，而这里就不需要处理这个逻辑了。这种场景和单例模式并不冲突，仅仅是将 <code class=\"language-text\">loop</code> 属性的控制权转移到了用户侧。</p>\n<p>这里我们举的 <code class=\"language-text\">LoopAudio</code> 是单例模式中扩充子类的一个例子，实际应用中扩充的子类可能依赖于一些特定的环境，如根据浏览器对 <code class=\"language-text\">Audio</code> 类的支持程度决定使用原生 <code class=\"language-text\">Audio</code> 还是伪造的 <code class=\"language-text\">DumbAudio</code>，抑或是根据设备性能决定使用高采样率的 <code class=\"language-text\">HighQualityAudio</code> 还是低采样率的 <code class=\"language-text\">LowQualityAudio</code>。</p>\n<h2>单例模式的完善</h2>\n<h3>用户侧的例子——音轨</h3>\n<p>前面提到，全局播放是指同一时间内，应用的所有组件都能操作唯一一个音频对象，这主要是针对歌曲、视频成品等内容而言。事实上，对于制作中的歌曲，同时存在多个<b>音轨</b>是非常常见的情况，如果你用 Pr、Au 等 Adobe 全家桶系列做过音频剪辑，这个概念你应该很熟悉。</p>\n<p>为了实现<b>音轨</b>这个功能，我们定义了 <code class=\"language-text\">Tracks</code> 类：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Tracks</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">constrcutor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tracks <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tracks<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> singletonAudio<span class=\"token punctuation\">.</span><span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tracks<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 所有音轨音量调节</span>\n    <span class=\"token function\">volumeUp</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">options</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 这里的 options 直接原样传入了，实际情况下可能会对 options 作额外的处理</span>\n        <span class=\"token comment\">// 例如，我们想调节所有音轨的整体音量，options 传入 overallVolume</span>\n        <span class=\"token comment\">// 综合考虑所有 audio 的音量，给每个 audio 的 volumeUp 方法传入合适的参数</span>\n        Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tracks<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">key</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">const</span> audio <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tracks<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            audio<span class=\"token punctuation\">.</span><span class=\"token function\">volumeUp</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>在这里，我们支持通过实例方法 <code class=\"language-text\">set</code> 动态新增音轨，但新增的每条音轨，我们都从 <code class=\"language-text\">singletonAudio.getInstance</code> 中获取，这样我们可以保证应用在使用 <code class=\"language-text\">tracks</code> 实例的 <code class=\"language-text\">set</code> 方法时，在传入一样的 <code class=\"language-text\">key</code> 的前提下，该 <code class=\"language-text\">key</code> 若还没有设置 <code class=\"language-text\">audio</code> 实例，则设置，如果设置过了，就直接返回（这是 <code class=\"language-text\">singletonAudio.getInstance</code> 本身的特性）。[1]</p>\n<p>同时，我们将 <code class=\"language-text\">singletonAudio</code> 修改如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> singletonAudio <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">Audio</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 同上文...</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">let</span> audios <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">const</span> _static <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">key<span class=\"token punctuation\">,</span> options</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// 若 audio 实例还未被创建，则创建并返回</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>audios<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                audios<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Audio</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token keyword\">return</span> audio<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> _static<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>对于这里对 <code class=\"language-text\">singletonAudio</code> 的修改，我们做一些补充说明：</p>\n<p>在文章的第二部分，我们说单例模式下全局播放只有一个 <code class=\"language-text\">audio</code> 实例，但在这里的场景下，全局不止一个 <code class=\"language-text\">audio</code> 实例。事实上，单例模式的定义里从来就没有严格限制其只能提供一个实例。这不矛盾么？</p>\n<p>注意看上面这句话的表述中的<b>提供</b>二字，单例模式的确会返回具有单例性质的<b>结构</b>，但单例这一性质体现在这些<b>结构</b>上，单例模式本身完全可以返回多个具有单例性质的对象（这是<b>结构</b>的一种）。</p>\n<blockquote>\n<p>This is because it is neither the object or \"class\" that's returned by a Singleton, it's a structure —— Addy Osmani</p>\n</blockquote>\n<p>好的，解决了为什么这里会出现多个 <code class=\"language-text\">audio</code> 实例后，我们看看之前的表述[1]，其中提到 <b>传入一样的 <code class=\"language-text\">key</code></b>，为什么 <code class=\"language-text\">key</code> 要一样呢？有了对于出现多个 <code class=\"language-text\">audio</code> 实例原因的补充，这里解释起来就方便很多了，<code class=\"language-text\">key</code> 标识 <code class=\"language-text\">singletonAudio</code> 返回结构中不同的单例，当 <code class=\"language-text\">key</code> 一样时，我们操作的就是同一个单例。</p>\n<h3>隐患</h3>\n<p>至此，我们完成了一个 <code class=\"language-text\">Tracks</code> 类，它可以管理多个 <code class=\"language-text\">audio</code> 实例，每个 <code class=\"language-text\">audio</code> 实例本身都具备单例的性质，但是这就没有问题了吗？</p>\n<p>注意在前面的 <code class=\"language-text\">tracks</code> 实例的 <code class=\"language-text\">set</code> 方法中，我们默认使用了单例模式 <code class=\"language-text\">singletonAudio</code>，即调用 <code class=\"language-text\">singletonAudio.getInstance</code> 给 <code class=\"language-text\">this.tracks[key]</code> 赋值，这么做事实上已经有了一个预设，即 <code class=\"language-text\">this.tracks[key]</code>——也就是某条音轨——必定是由 <code class=\"language-text\">singletonAudio</code> 创建出来的，这样一来，<code class=\"language-text\">Tracks</code> 类就直接与 <code class=\"language-text\">singletonAudio</code> 绑定了，如果后续 <code class=\"language-text\">singletonAudio</code> 作了一些修改，<code class=\"language-text\">Tracks</code> 类只能一起改。举个例子：</p>\n<p><code class=\"language-text\">Tracks</code> 类提供了 <code class=\"language-text\">set</code> 方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tracks<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> singletonAudio<span class=\"token punctuation\">.</span><span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里我们通过 <code class=\"language-text\">key</code> 标识不同的音轨，用 <code class=\"language-text\">options</code> 初始化每条音轨，但是，如果后面我们的 <code class=\"language-text\">singletonAudio</code> 发生更改，只提供 <code class=\"language-text\">getCollection(key)</code> 方法，这里的 <code class=\"language-text\">key</code> 用来实例化 <code class=\"language-text\">Audio</code> 的不同子类，该方法返回的对象 <code class=\"language-text\">collection</code> 再提供原有的 <code class=\"language-text\">getInstance</code> 方法以获取该子类下的不同单例。这样一来，原来的 <code class=\"language-text\">set</code> 方法将会失效。<code class=\"language-text\">singletonAudio</code> 改动带动了非业务下游组件（这里是 <code class=\"language-text\">Tracks</code>）改动。而类似的情况有很多，例如全局播放条组件、前端音视频播放器、本地音视频采集等等。</p>\n<p>由于 <code class=\"language-text\">singletonAudio</code> 抽象层级较高（其封装的是音频能力，所有涉及音频能力的非业务下游组件都可能使用到它），后续容易产生大量依赖它的如 <code class=\"language-text\">Tracks</code> 这样的非业务下游组件，由于这些组件本身不承载业务逻辑，我们也很难事先设计好架构同步 <code class=\"language-text\">Tracks</code> 类与其他依赖于 <code class=\"language-text\">singletonAudio</code> 的修改，<b>此时维护这些下游组件只能一个个修改</b>。</p>\n<p>无论如何，这种上游组件修改带动整个用户侧一起作修改的做法，都是极为不可取的，它会浪费许多不必要的时间来对一次更新作兼容，成本过高。</p>\n<blockquote>\n<p>你可能要问，组件特性更新向下兼容，大版本不向下兼容不就可以了么？是，但这是在用 npm 管理公共组件的前提下，如果仅仅是单个应用内部的公共组件，还要引入组件版本的概念，未免不太合适。如果为了这个把应用仓库改造成 monorepo，又有些小题大做了。</p>\n</blockquote>\n<h3>应用侧才是出路？</h3>\n<p>上述问题之所以存在，就是因为 <code class=\"language-text\">Tracks</code> 类的写法耦合了 <code class=\"language-text\">singletonAudio.getInstance</code>，即上面说的做了 <code class=\"language-text\">this.tracks[key]</code> 必定由 <code class=\"language-text\">singletonAudio</code> 创建出来的预设。这是一种很常见的反设计模式：<strong>I know where you live</strong>，如果一个组件对另一个组件的了解过多，以至于在组件中有大量基于另一个组件的逻辑，那么上游组件一旦变动，下游组件除了修改外没有办法。组件之间，除了必要的通信信息，其他信息应该遵循知道得越少越好的原则。</p>\n<p>为了避免上面这种“一次更新，全局修改”的情况发生，考虑到应用侧本身就管理着业务逻辑，我们不妨把 <code class=\"language-text\">this.tracks[key]</code> 是否具有单例性质的控制权交给应用侧，<code class=\"language-text\">Tracks</code> 类改写如下： </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Tracks</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">constrcutor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tracks <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tracks<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> options<span class=\"token punctuation\">.</span>audio<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tracks<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 所有音轨音量调节</span>\n    <span class=\"token function\">volumeUp</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">options</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 同上... </span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里的修改其实很简单，变动的只有 <code class=\"language-text\">set</code> 方法，注意到我们将 <code class=\"language-text\">options.audio</code> 赋值给了 <code class=\"language-text\">this.tracks[key]</code>，也就是说，某个音轨是否采用上面具有单例性质的 <code class=\"language-text\">audio</code> 是由实际的业务逻辑决定的，相对于非业务下游组件，业务组件本身的业务上下文使其更容易管理多种、多个像 <code class=\"language-text\">Tracks</code> 这样的组件。</p>\n<p>在业务侧，我们可以通过 <code class=\"language-text\">singletonAudio.getInstance</code> 实例化一个 <code class=\"language-text\">audio</code> 单例，然后将这个 <code class=\"language-text\">audio</code> 存储于顶层 state 中（使用任一状态管理库），这样在所有用到 <code class=\"language-text\">Tracks</code> 等类的地方，我们拿到这个全局 <code class=\"language-text\">audio</code> 作为依赖注入到 <code class=\"language-text\">Tracks</code> 类中，此时我们就把 <code class=\"language-text\">Tracks</code>、全局播放条组件这些类的修改收敛到了一个地方。如果发生了上面<b>隐患</b>一节例子中的修改，我们只需要在应用侧处理 <code class=\"language-text\">getCollection</code> 和 <code class=\"language-text\">getInstance</code> 逻辑，对于 <code class=\"language-text\">Tracks</code> 这些类，它们还是接收一个 <code class=\"language-text\">audio</code> 实例，代码是无须变动的。</p>\n<h2>小结</h2>\n<p>本文从音频播放能力中常见的全局播放说起，进而引申出了单例模式的讨论，最后通过一个单例模式的应用，讨论了该模式在实际应用中可能存在的缺陷，并提出了解决方法。</p>\n<h3>参考资料</h3>\n<ul>\n<li>《JavaScript设计模式》Addy Osmani著</li>\n</ul>\n<blockquote>\n<p>本文发布自 <a href=\"https://github.com/x-orpheus\">网易云音乐前端团队</a>，文章未经授权禁止任何形式的转载。我们一直在招人，如果你恰好准备换工作，又恰好喜欢云音乐，那就 <a href=\"mailto:grp.music-fe@corp.netease.com\">加入我们</a>！</p>\n</blockquote>","frontmatter":{"title":"从全局播放到单例模式","date":"2020-03-24","description":"本文以音频能力中的全局播放为切入点，探讨单例模式在前端业务中的应用。文中代码均为 React 组件内代码。"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/singleton-pattern/","previous":{"fields":{"slug":"/threejs/"},"frontmatter":{"title":"Three.js 动效方案"}},"next":{"fields":{"slug":"/web-video/"},"frontmatter":{"title":"Web 视频播放的那些事儿"}}}}}