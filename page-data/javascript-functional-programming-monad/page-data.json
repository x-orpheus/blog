{"componentChunkName":"component---src-templates-blog-post-js","path":"/javascript-functional-programming-monad/","webpackCompilationHash":"df13f47ed208f2315392","result":{"data":{"site":{"siteMetadata":{"title":"云音乐大前端专栏","author":"云音乐大前端团队","siteUrl":"https://musicfe.dev"}},"markdownRemark":{"id":"408e2f46-dd09-5dc8-a564-82310f633b36","excerpt":"russian dolls 图片来源: https://unsplash.com/photos/RPLwFFzNvp0 本文作者：赵祥涛 前面两篇分别介绍了 Functor 和 Applicative 的概念和实际应用，并列举了几个具体的例子，说明了 Functor 和 Applicative…","html":"<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/5507082808/23cf/319b/5b26/63ff0fc33c21d14832865389e6a5dcb7.png\" alt=\"russian dolls\"></p>\n<p>图片来源: <a href=\"https://unsplash.com/photos/RPLwFFzNvp0\">https://unsplash.com/photos/RPLwFFzNvp0</a></p>\n<blockquote>\n<p>本文作者：<a href=\"https://github.com/sylvenas\">赵祥涛</a></p>\n</blockquote>\n<p>前面两篇分别介绍了 <a href=\"https://musicfe.dev/javascript-functional-programming-advance/\">Functor</a> 和 <a href=\"https://musicfe.dev/javascript-functional-programming-functor/\">Applicative</a> 的概念和实际应用，并列举了几个具体的例子，说明了 Functor 和 Applicative 的实际用途，比如：使用 <code class=\"language-text\">Either</code> 来处理无处不在的 <code class=\"language-text\">null</code> 和创建可组合的 <code class=\"language-text\">try-catch</code>；使用 Applicative 来做高度灵活高度可拓展的表单校验；相信读者应该已经牢牢掌握了 Functor 的核心：<strong>map-应用一个函数到包裹的值</strong>，Applicative的核心：<strong>ap-应用一个包裹的函数到一个包裹的值</strong>。</p>\n<p>别忘了之前遗留的几个问题：</p>\n<ul>\n<li>如何解决嵌套的 <code class=\"language-text\">try-catch</code></li>\n<li>异步函数的组合</li>\n<li>Promise 也是一种 Functor ?</li>\n</ul>\n<p>三个问题从易到难一个一个的解决，先从第一个：嵌套的 <code class=\"language-text\">try-catch</code> 开始入手。</p>\n<blockquote>\n<p>本篇文章建立在前两篇的基础之上，所以建议先阅读前两篇的文章，再读本篇，不然可能会对某些概念和名词感到困惑</p>\n</blockquote>\n<h2>嵌套的 Array</h2>\n<p>Javascript Array 的 <code class=\"language-text\">map</code> 方法，相信开发者们都很熟悉，并且几乎在每天的编程中都会用到，但 Array 原型链上的另一个方法 <code class=\"language-text\">Array.prototype.flatMap</code> 可能很多人没怎么用过，从字面意思上理解就是<code class=\"language-text\">扁平化的 map</code>，实际作用也确实是的，看一个和 <code class=\"language-text\">map</code> 做对比的使用案例：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span>\n\narr<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span>x <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// => [[2], [4], [6], [8]]</span>\n\narr<span class=\"token punctuation\">.</span><span class=\"token function\">flatMap</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span>x <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// => [2, 4, 6, 8]</span></code></pre></div>\n<p><code class=\"language-text\">flatMap</code> 相对于 <code class=\"language-text\">map</code> 的区别是：</p>\n<ul>\n<li><code class=\"language-text\">map</code> 是把函数执行的结果，放在一起然后装进 Box 中；</li>\n<li><code class=\"language-text\">flatMap</code> 的结果是把<strong>函数执行的结果分别去掉一层“包装”</strong>，然后放在一起装进 Box 中</li>\n</ul>\n<p>所以 <code class=\"language-text\">flatMap</code> 相当于是先 <code class=\"language-text\">map</code> (映射)然后 <code class=\"language-text\">flat</code> (拍平)， 仅仅是多了一个“去包装”的操作！</p>\n<h2>俄罗斯套娃</h2>\n<p>上面介绍了 Array 的一种先 <code class=\"language-text\">map</code> 在 <code class=\"language-text\">flat</code> 的方法，Array 也是 <code class=\"language-text\">Box</code> 理念的一个具体实现案例，那其他的 Box 呢？比如前面两篇一直在用的 <code class=\"language-text\">Either</code> 又是如何实现的呢？从一个更简单的函数组合的案例出发，需求是：编写一个获取用户地址的街道名称函数：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">compose</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token operator\">...</span>fns</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> fns<span class=\"token punctuation\">.</span><span class=\"token function\">reduceRight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">v<span class=\"token punctuation\">,</span> f</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">address</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">user</span> <span class=\"token operator\">=></span> user<span class=\"token punctuation\">.</span>address\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">street</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">address</span> <span class=\"token operator\">=></span> address<span class=\"token punctuation\">.</span>street\n\n<span class=\"token keyword\">const</span> app <span class=\"token operator\">=</span> <span class=\"token function\">compose</span><span class=\"token punctuation\">(</span>street<span class=\"token punctuation\">,</span> address<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> user <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    address<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        street<span class=\"token punctuation\">:</span> <span class=\"token string\">'长河'</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token function\">app</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span> <span class=\"token comment\">// => 长河</span></code></pre></div>\n<p>函数组合的理论也非常简单，只要上一个函数的返回值类型可以作为下一个函数的入参就可以放心大胆的进行组合了。</p>\n<p>值得警惕的是，<code class=\"language-text\">user</code> 对象上面 <code class=\"language-text\">address</code> 属性值可能为 <code class=\"language-text\">null</code> ，上面的这段代码如果不做任何防范，那么 <code class=\"language-text\">TypeError</code> 的错误是可能发生的。这个问题不用担心，毕竟之前已经准备好了用来处理 <code class=\"language-text\">null/undefined</code> 的 <code class=\"language-text\">Either</code> 函子，可以使用 <code class=\"language-text\">fromNullable</code> 包装一下上面代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">address</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">user</span> <span class=\"token operator\">=></span> <span class=\"token function\">fromNullable</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">u</span> <span class=\"token operator\">=></span> u<span class=\"token punctuation\">.</span>address<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">street</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">address</span> <span class=\"token operator\">=></span> <span class=\"token function\">fromNullable</span><span class=\"token punctuation\">(</span>address<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a</span> <span class=\"token operator\">=></span> a<span class=\"token punctuation\">.</span>street<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">app</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">user</span> <span class=\"token operator\">=></span>\n    <span class=\"token function\">address</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span>     <span class=\"token comment\">// Either(address)                                       </span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>street<span class=\"token punctuation\">)</span>  <span class=\"token comment\">// Either(Either(street))</span>\n\n<span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token function\">app</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span> <span class=\"token comment\">// => Rirgt(Right('长河'))</span></code></pre></div>\n<p>审视一下上面的代码，<code class=\"language-text\">street</code> 函数返回的是一个 <code class=\"language-text\">Either</code> ，但是别忘了，<code class=\"language-text\">map</code> 方法( <code class=\"language-text\">map: f =&gt; Right(f(x))</code> )会把函数执行的结果重新包装进“盒子”中，也就是：最终得到的结果是：<code class=\"language-text\">Rirgt(Right(&#39;长河&#39;))</code>。</p>\n<p>这很明显不是我们想要的结果，我们只想要被包裹一层的 <code class=\"language-text\">street</code> ，问题是出现 <code class=\"language-text\">map</code> 方法上(map 会进行二次包装)，那么只要使用 <code class=\"language-text\">fold</code> 方法把 <code class=\"language-text\">street</code> 函数执行的结果从“盒子”里“拆包”解放出来即可。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">app</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">user</span> <span class=\"token operator\">=></span>\n        <span class=\"token function\">address</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span>                              <span class=\"token comment\">// Either(address)</span>\n       <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">s</span> <span class=\"token operator\">=></span> <span class=\"token function\">street</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">fold</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x<span class=\"token punctuation\">,</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>   <span class=\"token comment\">// Either(street)</span>\n       <span class=\"token punctuation\">.</span><span class=\"token function\">fold</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token string\">'default street'</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x<span class=\"token punctuation\">)</span>       <span class=\"token comment\">// street</span>\n       \n<span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token function\">app</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span>  <span class=\"token comment\">// => '长河'</span></code></pre></div>\n<p>毫无疑问，有几次包装，就需要几次“拆包”操作，这样做逻辑上自然没有问题。但这岂不是和前端常见的<a href=\"http://callbackhell.com/\">回调地狱</a>问题很类似，这样的代码写下去实在是太难维护和阅读，总不能写一行就要数数有几层包装吧！</p>\n<p>这简直是代码版本的俄罗斯套娃：</p>\n<p><img src=\"https://d1.music.126.net/dmusic/obj/w5zCg8OAw6HDjzjDgMK_/5473369813/a3d5/d99f/df90/f221f2e6dd3b4a8fc6ee7bc400ba4008.gif?download=russian-dolls.gif\" alt=\"russian-dolls\"></p>\n<p>出现两层包装的原因是：<code class=\"language-text\">map</code> 会把函数计算的结果重新包装进 Box 中，而这一层包装有点赘余，因为之后立即进行了拆箱操作，这非常类似于 <code class=\"language-text\">Array flatmap</code> (先 map 然后 flat )。</p>\n<p><strong>因为函数的执行结果已经是被包装好了的，所以只需要一个方法( flatMap )直接执行函数，不做其他的任何操作</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Right</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">flatMap</span><span class=\"token punctuation\">:</span> <span class=\"token parameter\">f</span> <span class=\"token operator\">=></span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Left</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">flatMap</span><span class=\"token punctuation\">:</span> <span class=\"token parameter\">f</span> <span class=\"token operator\">=></span> <span class=\"token function\">Left</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">app</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">user</span> <span class=\"token operator\">=></span>\n    <span class=\"token function\">address</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span>                             <span class=\"token comment\">// Either(address)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">flatMap</span><span class=\"token punctuation\">(</span>street<span class=\"token punctuation\">)</span>                      <span class=\"token comment\">// Either(street)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">flod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token string\">'default street'</span><span class=\"token punctuation\">,</span><span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x<span class=\"token punctuation\">)</span>  <span class=\"token comment\">// street</span></code></pre></div>\n<p><code class=\"language-text\">map</code> 和 <code class=\"language-text\">flatMap</code> 的不同点：<code class=\"language-text\">map</code> 方法接收一个仅仅变换容器内值的函数，所以需要用 Box 重新包装；但是 <code class=\"language-text\">flatMap</code> 接收<strong>一个返回Box类型的函数</strong>，直接调用即可。</p>\n<p><code class=\"language-text\">map</code> 和 <code class=\"language-text\">flatMap</code> 的相同点却是非常明显的：都是返回一个 Box 的实例，方便后面继续链式的调用。</p>\n<blockquote>\n<p><code class=\"language-text\">flatMap</code> 方法和 <code class=\"language-text\">flod</code> 方法逻辑一样？这里得承认他们确实很类似，但是他们的使用场景却完全不同！<code class=\"language-text\">flod</code> 的用途是把一个值从 Box 中解放出来；<code class=\"language-text\">flatMap</code> 的用途是把一个返回 Box 的函数应用到一个 Box 上，这样后面可以继续保持链式的调用。</p>\n</blockquote>\n<blockquote>\n<p>根据<a href=\"https://github.com/fantasyland/fantasy-land#chain\">规范</a> <code class=\"language-text\">flatMap</code> 方法后面会改写为 <code class=\"language-text\">chain</code>，在别的语言中，可能也称为 <code class=\"language-text\">bind</code>。</p>\n</blockquote>\n<p>既然解决了嵌套的 <code class=\"language-text\">Either</code> 问题，那么嵌套的 <code class=\"language-text\">try-catch</code> ，自然用同样的理论也可以迎刃而解了：</p>\n<p>举例来说，如果要从文件系统读取一个配置文件，然后读取内容(请注意 <code class=\"language-text\">fs.readFileSync</code> 和 <code class=\"language-text\">JSON.parse</code> 都是可能发生错误的，所以会用 <code class=\"language-text\">try-catch</code> 包裹)：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">readConfig</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">filepath</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> str <span class=\"token operator\">=</span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">readFileSync</span><span class=\"token punctuation\">(</span>filepath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> config <span class=\"token operator\">=</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> config<span class=\"token punctuation\">.</span>version\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">'0.0.0'</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token function\">readConfig</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/config.json'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span> <span class=\"token comment\">// => '1.0.0'</span></code></pre></div>\n<p>现在使用“盒子”理念 + “chain” 函数重写上面的代码为：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">readConfig</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">filepath</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n    <span class=\"token function\">tryCatch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">readFileSync</span><span class=\"token punctuation\">(</span>filepath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>             <span class=\"token comment\">// Either('')</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">chain</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">json</span> <span class=\"token operator\">=></span> <span class=\"token function\">tryCatch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>json<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// Either('') </span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">fold</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token string\">'0.0.0'</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">c</span> <span class=\"token operator\">=></span> c<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token function\">readConfig</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/config.json'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span> <span class=\"token comment\">// => '1.0.0'</span></code></pre></div>\n<p>如果一个 Functor 实现了 <code class=\"language-text\">chain</code> 方法，那么我们可以称这个函子为<strong>单子(Monad)</strong>，不错单子的概念就是这么简单；\n如果你去 Google 搜索 <code class=\"language-text\">Monad</code> ，有无数篇在讲解 <code class=\"language-text\">Monad</code> 的文章，其中最经(戏)典(虐)的一个解释为：</p>\n<blockquote>\n<p>“A monad is just a monoid in the category of endofunctors. What’s the problem?”</p>\n</blockquote>\n<p><img src=\"https://d1.music.126.net/dmusic/obj/w5zCg8OAw6HDjzjDgMK_/5473423836/7034/6444/5f4c/6221ec38ef408e8a25b7be620202b998.gif?download=tenor.gif\" alt=\"monad\"></p>\n<p>上面这句话的出处是<a href=\"http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html\">brief-incomplete-and-mostly-wrong</a>,完全是为了吐槽 Haskell，理论上没有错，但更多的是调侃(<del>该文章极其经典，点明了所有主流开发语言的“特色与优点”，推荐阅读背诵</del>)。</p>\n<p>而 Monad 的准确定义是：</p>\n<blockquote>\n<p>All told, a monad in X is just a monoid in the category of endofunctors of X, with product × replaced by composition of endofunctors and unit set by the identity endofunctor. -- <a href=\"https://en.wikipedia.org/wiki/Saunders_Mac_Lane\">Saunders Mac Lane</a></p>\n</blockquote>\n<p>所以上面这个定义你看懂了吗？(<del>别打我</del>)看不懂，真的没有关系，因为那是为专业的数学学生而准备的，我们只要掌握 Monad 在编程中可以理解为 <code class=\"language-text\">chainable</code> 的对象，用来解决嵌套的 Box 问题，抓住这个重点已经足够了。</p>\n<h2>异步</h2>\n<p>毫无疑问 异步 是 JavaScript 世界的主流，从按钮的 <code class=\"language-text\">onclick</code> 点击回调，到 AJAX 请求的 <code class=\"language-text\">onload</code> 回调，再到 Node.js 里的 <code class=\"language-text\">readFile</code> 回调，这种根基级的手法都万变不离其宗，「异步非阻塞」意味着一种以回调函数为基础的编程范式。</p>\n<p>关于异步和事件循环的理论，可以参考网易云音乐团队的另一篇文章：<a href=\"https://musicfe.dev/eventloop/\">聊聊 JavaScript 的并发、异步和事件循环</a></p>\n<h3>callback 与 异步</h3>\n<p>从最简单的回调函数开始，首先看一典型的 Node.js 风格的 callback :</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">getUrl</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">url</span> <span class=\"token operator\">=></span> <span class=\"token parameter\">callback</span> <span class=\"token operator\">=></span> <span class=\"token function\">request</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> getSomeJSON <span class=\"token operator\">=</span> <span class=\"token function\">getUrl</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http://example.com/somedata.json'</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">getSomeJSON</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> data</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//do something with err</span>\n  <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//do something with data</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>这是一段简单的异步 HTTP 请求，首先采用柯里化的方式传入 <code class=\"language-text\">url</code> ，然后传入 <code class=\"language-text\">callback</code> ，这种风格有什么缺点呢？</p>\n<ul>\n<li>1.函数的调用者无法直接控制请求，必须要把所有的后续操作放在 <code class=\"language-text\">callback</code> 里面</li>\n<li>2.函数无法组合，因为 <code class=\"language-text\">getSomeJSON</code> 调用之后没有返回任何结果</li>\n</ul>\n<p>还有一个关键点在于，<code class=\"language-text\">callback</code> 接收两个参数，一个错误信息，一个成功的数据，这导致我们不得不在一个函数里面同时处理错误与数据的逻辑。</p>\n<p>那么转换一下思路，<strong>与其传递一个接收两个参数(err &#x26; data)的函数，不如传递两个函数(handleError &#x26; handleData)，每个接收一个参数</strong>。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">getUrl</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">url</span> <span class=\"token operator\">=></span>\n    <span class=\"token punctuation\">(</span><span class=\"token parameter\">reject<span class=\"token punctuation\">,</span> resolve</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n        <span class=\"token function\">request</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> data</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n            err<span class=\"token operator\">?</span> <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>现在调用 <code class=\"language-text\">getUrl</code> 之后，我们可以继续传递 <code class=\"language-text\">handleError</code> 和 <code class=\"language-text\">handleData</code></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> getSomeJSON <span class=\"token operator\">=</span> <span class=\"token function\">getUrl</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http://example.com/somedata.json'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">handleError</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">err</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Error fetching JSON'</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> handleData <span class=\"token operator\">=</span> <span class=\"token function\">compose</span><span class=\"token punctuation\">(</span>renderData<span class=\"token punctuation\">,</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span>parse<span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">getSomeJSON</span><span class=\"token punctuation\">(</span>handleError<span class=\"token punctuation\">,</span> handleData<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 触发请求</span></code></pre></div>\n<p>现在完全分离了 <code class=\"language-text\">handleData</code> 和 <code class=\"language-text\">handleError</code> 的逻辑，并且 <code class=\"language-text\">handleData</code> 函数已经可以按照我们的期望进行组合了，而<code class=\"language-text\">(reject, resolve) =&gt; {}</code> 函数我们称之为fork，意为：两个“分支”。</p>\n<h3>Task与异步</h3>\n<p>现在我们发现了另外一个问题，我们总是需要在 <code class=\"language-text\">handleData</code> 中进行 <code class=\"language-text\">JSON.parse</code> 操作，因为把字符串转换为 JSON 是任何数据处理逻辑的第一步，如果我们能把 <code class=\"language-text\">getSomeJSON</code> 与 <code class=\"language-text\">JSON.parse</code> 函数组合在一起就好了；现在问题明确了：<strong>如何把一个普通的函数和fork函数进行组合？</strong></p>\n<p>这个问题看上去非常棘手，不过可以从简单的问题开始一步步解决，假设现在有字符串 <code class=\"language-text\">stringifyJson</code> ，如何转换为 JSON 呢，借用前面一章中介绍的<a href=\"https://musicfe.dev/javascript-functional-programming-functor/\">LazyBox</a>的概念：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> stringifyJson<span class=\"token operator\">=</span> <span class=\"token string\">'{\"a\":1}'</span>\n\n<span class=\"token function\">LazyBox</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> stringifyJson<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span>parse<span class=\"token punctuation\">)</span> <span class=\"token comment\">// => LazyBox({ a: 1 })</span></code></pre></div>\n<p>我们可以把一个函数包装进 <code class=\"language-text\">LazyBox</code> 中，然后通过 <code class=\"language-text\">map</code> 不断的进行函数组合，直到最后调用 <code class=\"language-text\">fold</code> 函数，真正的触发函数调用；   </p>\n<p><code class=\"language-text\">LazyBox</code> 用来包裹同步的函数，那么同理对于处理异步逻辑的 <code class=\"language-text\">fork</code> 函数，也可以用一个盒子包装起来，然后 <code class=\"language-text\">map</code> 普通函数 <code class=\"language-text\">f</code> ，不也可以实现函数组合吗？对于异步的逻辑，可以称之为 <code class=\"language-text\">Task</code> (任务：将来才会完成某个目标或者达成某种结果，<del>是不是很好理解</del>)</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Task</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">fork</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">map</span><span class=\"token punctuation\">:</span> <span class=\"token parameter\">f</span> <span class=\"token operator\">=></span> <span class=\"token function\">Task</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">reject<span class=\"token punctuation\">,</span> resolve</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>          <span class=\"token comment\">// return another Task, including a new fork.</span>\n            <span class=\"token function\">fork</span><span class=\"token punctuation\">(</span>reject<span class=\"token punctuation\">,</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\">// when called,the new fork will run `f` over the value, before calling `resolve`</span>\n    fork<span class=\"token punctuation\">,</span>\n    <span class=\"token function-variable function\">inspect</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token string\">'Task(?)'</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">Task</code> 的 <code class=\"language-text\">map</code> 方法，接收一个函数 <code class=\"language-text\">f</code> ，返回一个新的 <code class=\"language-text\">Task</code>，关键点在：新的 <code class=\"language-text\">fork</code> 函数会调用上一个 <code class=\"language-text\">fork</code> ，如果是正确的分支则 <code class=\"language-text\">resolve</code> 被函数 <code class=\"language-text\">f</code> 计算过后的结果，如果是失败的分支，则传递 <code class=\"language-text\">reject</code>。</p>\n<blockquote>\n<p>如果之前没有深入了解过 Promise 的实现原理，可能这里比较难以理解，但是请停下来，花点时间思考一下。</p>\n</blockquote>\n<p>现在使用 <code class=\"language-text\">Task</code> 改写一下 <code class=\"language-text\">readConfig</code> 函数：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">readConfig</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">filepath</span> <span class=\"token operator\">=></span> <span class=\"token function\">Task</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">reject<span class=\"token punctuation\">,</span> resolve</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n    fs<span class=\"token punctuation\">.</span><span class=\"token function\">readFile</span><span class=\"token punctuation\">(</span>filepath<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> data</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n        err <span class=\"token operator\">?</span> <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> app <span class=\"token operator\">=</span> <span class=\"token function\">readConfig</span><span class=\"token punctuation\">(</span><span class=\"token string\">'config.json'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span>parse<span class=\"token punctuation\">)</span>\n\napp<span class=\"token punctuation\">.</span><span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'something went wrong'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">json</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'json'</span><span class=\"token punctuation\">,</span> json<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">Task.map</code> 和 <code class=\"language-text\">LazyBox</code> 的 <code class=\"language-text\">map</code> 完全类似，一直都是在做函数组合的工作，并没有进行实际的函数调用，<code class=\"language-text\">LazyBox</code> 最后通过调用 <code class=\"language-text\">fold</code> 真正实现函数调用，而 <code class=\"language-text\">Task</code> 最后通过调用 <code class=\"language-text\">fork</code> ，实现异步函数的执行。</p>\n<h3>Task与异步函数的组合</h3>\n<p>现在通过 <code class=\"language-text\">Task</code> 实现了一个比较“优雅”的 <code class=\"language-text\">readConfig</code> 函数，如果要继续修改配置文件并保存到本地，又该如何处理呢？先从 <code class=\"language-text\">writeConfig</code> 函数开始吧，完全仿照 <code class=\"language-text\">readConfig</code> 函数的写法：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> app <span class=\"token operator\">=</span> <span class=\"token function\">readConfig</span><span class=\"token punctuation\">(</span>readPath<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span>parse<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">c</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> version<span class=\"token punctuation\">:</span> c<span class=\"token punctuation\">.</span>version <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span>stringify<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">writeConfig</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">filepath<span class=\"token punctuation\">,</span> contents</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n    <span class=\"token function\">Task</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">reject<span class=\"token punctuation\">,</span> resolve</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        fs<span class=\"token punctuation\">.</span><span class=\"token function\">writeFile</span><span class=\"token punctuation\">(</span>filepath<span class=\"token punctuation\">,</span> contents<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> _</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n            err <span class=\"token operator\">?</span> <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>contents<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>那么怎么继续把 <code class=\"language-text\">writeConfig</code> 应用到 <code class=\"language-text\">app</code> 上呢，既然 <code class=\"language-text\">writeConfig</code> 函数返回一个 <code class=\"language-text\">Task</code>，那么很明显需要一个类似 <code class=\"language-text\">Array.prototype.flatMap</code> 和 <code class=\"language-text\">Either.chain</code> 函数，帮我们把这个返回 <code class=\"language-text\">Task</code> 的函数应用到 <code class=\"language-text\">app</code> 上：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Task</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">fork</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">chain</span><span class=\"token punctuation\">:</span> <span class=\"token parameter\">f</span> <span class=\"token operator\">=></span> <span class=\"token function\">Task</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">reject<span class=\"token punctuation\">,</span> resolve</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>                   <span class=\"token comment\">// return another Task</span>\n            <span class=\"token function\">fork</span><span class=\"token punctuation\">(</span>reject<span class=\"token punctuation\">,</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">fork</span><span class=\"token punctuation\">(</span>reject<span class=\"token punctuation\">,</span> resolve<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// calling `f` with the eventual value</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>类似于 <code class=\"language-text\">Either</code> 中的 <code class=\"language-text\">chain</code> 函数，首先会直接调用函数 <code class=\"language-text\">f</code> (返回TaskB)，然后传入<code class=\"language-text\">(reject, resolve)</code>调用 <code class=\"language-text\">TaskB</code> 的 <code class=\"language-text\">fork</code> 函数去处理后续的逻辑。</p>\n<p>现在就可以流畅的使用 <code class=\"language-text\">chain</code> 继续组合 <code class=\"language-text\">writeConfig</code> 函数了</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> app <span class=\"token operator\">=</span> <span class=\"token function\">readConfig</span><span class=\"token punctuation\">(</span>readPath<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span>parse<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">c</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> version<span class=\"token punctuation\">:</span> c<span class=\"token punctuation\">.</span>version <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span>stringify<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">chain</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">c</span> <span class=\"token operator\">=></span> <span class=\"token function\">writeConfig</span><span class=\"token punctuation\">(</span>writeFilepath<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\napp<span class=\"token punctuation\">.</span><span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'something went wrong'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n    <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'read and write config success'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>看到这里，应该可以举一反三的想到，需要链式调用的 HTTP 请求，比如：连续调用两个接口，第二个接口依赖第一个接口的返回值作为参数，那么完全可以用 <code class=\"language-text\">chain</code> 组合两个异步 HTTP 请求：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">httpGet</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">content</span> <span class=\"token operator\">=></span> <span class=\"token function\">Task</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">rej<span class=\"token punctuation\">,</span> res</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">res</span><span class=\"token punctuation\">(</span>content<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">getUser</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">id</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">httpGet</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Melo'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">getAge</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">name</span> <span class=\"token operator\">=></span> <span class=\"token function\">httpGet</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span><span class=\"token string\">'id'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">chain</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span> <span class=\"token operator\">=></span> <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">+</span> <span class=\"token string\">' 18'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">fork</span><span class=\"token punctuation\">(</span>console<span class=\"token punctuation\">.</span>error<span class=\"token punctuation\">,</span> console<span class=\"token punctuation\">.</span>log<span class=\"token punctuation\">)</span> <span class=\"token comment\">// => 4000ms later， log： \"Melo 18\"</span></code></pre></div>\n<h2>Monad VS Promise</h2>\n<p><code class=\"language-text\">Task</code> 的代码实现，不如之前介绍的 <code class=\"language-text\">Box</code>，<code class=\"language-text\">Either</code>， <code class=\"language-text\">LazyBox</code> 那么直观和好理解，但是请仔细思考和理解一下，你会发现 <code class=\"language-text\">Task</code> 和 <code class=\"language-text\">Promise</code> 是非常非常相似的，甚至我们可以认为 <code class=\"language-text\">Task</code> 就是一个 Lazy-Promise ：<strong>Promise 是在创建的时候立即开始执行，而 Task 是在调用 fork 之后，才会开始执行</strong>。</p>\n<p>关于读取配置文件，修改内容，然后重新保存到本地，我想大家都可以轻松的写出来 Promise 版本的实现，作为对比展示一下示例代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">readConfig</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">filepath</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve<span class=\"token punctuation\">,</span> reject</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n    fs<span class=\"token punctuation\">.</span><span class=\"token function\">readFile</span><span class=\"token punctuation\">(</span>filepath<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> data</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n        err <span class=\"token operator\">?</span> <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">writeConfig</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">filepath<span class=\"token punctuation\">,</span> contents</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve<span class=\"token punctuation\">,</span> reject</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    fs<span class=\"token punctuation\">.</span><span class=\"token function\">writeFile</span><span class=\"token punctuation\">(</span>filepath<span class=\"token punctuation\">,</span> contents<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> _</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n        err <span class=\"token operator\">?</span> <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>contents<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">readConfig</span><span class=\"token punctuation\">(</span>readPath<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span>parse<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">c</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> version<span class=\"token punctuation\">:</span> c<span class=\"token punctuation\">.</span>version <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span>stringify<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">c</span> <span class=\"token operator\">=></span> <span class=\"token function\">writeConfig</span><span class=\"token punctuation\">(</span>writeFilepath<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>两个版本中 <code class=\"language-text\">readConfig</code> 和 <code class=\"language-text\">writeConfig</code> 的实现非常类似，不再叙述；关键的不同点在于：Task 版本的组合函数使用的是 <code class=\"language-text\">map</code> 和 <code class=\"language-text\">chain</code> 函数，而 Promise 版本一直使用的都是 <code class=\"language-text\">then</code>。所以 Promise 看上去和 Monad 非常类似，那么不禁要问，Promise 是不是 Monad 呢？</p>\n<p>那么可以和最简单的 <code class=\"language-text\">Box</code> Monad 做个对比:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Box</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">map</span><span class=\"token punctuation\">:</span> <span class=\"token parameter\">f</span> <span class=\"token operator\">=></span> <span class=\"token function\">Box</span><span class=\"token punctuation\">(</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function-variable function\">chain</span><span class=\"token punctuation\">:</span> <span class=\"token parameter\">f</span> <span class=\"token operator\">=></span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> box1 <span class=\"token operator\">=</span> <span class=\"token function\">Box</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>                          <span class=\"token comment\">// => Box(1)</span>\n<span class=\"token keyword\">const</span> promise1 <span class=\"token operator\">=</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>          <span class=\"token comment\">// => Promise(1)</span>\n    \nbox1<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>                         <span class=\"token comment\">// => Box(2)</span>\npromise1<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>                    <span class=\"token comment\">// => Promise(2)</span>\n\n<span class=\"token comment\">// -----------------</span>\n\nbox1<span class=\"token punctuation\">.</span><span class=\"token function\">chain</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> <span class=\"token function\">Box</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>                 <span class=\"token comment\">// => Box(2)</span>\npromise1<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// => Promise(2)</span></code></pre></div>\n<p>可以发现，如果函数返回的是没有被包裹的值，<code class=\"language-text\">then</code> 和 <code class=\"language-text\">map</code> 的行为很类似；如果函数返回的是包裹的值，<code class=\"language-text\">then</code> 和 <code class=\"language-text\">chain</code> 很类似，都会去掉一层包装，从这个角度看 Promise 和Functor/Monad 都很类似，符合他们的数学规则。</p>\n<p>下面继续看：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">box1<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> <span class=\"token function\">Box</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>                   <span class=\"token comment\">// => Box(Box(2))</span>\npromise1<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// => Promise(2)</span>\n\nbox1<span class=\"token punctuation\">.</span><span class=\"token function\">chain</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>                      <span class=\"token comment\">// => 2</span>\npromise1<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>                   <span class=\"token comment\">// => Promise(2)</span></code></pre></div>\n<p>如果把一个返回包裹的值的函数，传递给 <code class=\"language-text\">then</code>，不会像 Functor 那样得到一个被包裹两层的值，而是只有一层；同样的把一个返回普通值的函数传递给 <code class=\"language-text\">then</code>，我们依然得到的是一个Promise，而 <code class=\"language-text\">chain</code> 的结果是去掉一层包裹，得到了值。从这个角度看，Promise 同时打破了 Functor 和 Monad 的数学规则。<strong>所以严格意义来说 Promise 不是一个 Monad</strong>，但是不可否认 Promise 的设计肯定有不少灵感来自 Monad。</p>\n<blockquote>\n<p>这一小节的内容较为难理解，主要难在 Task 的实现原理和异步函数的组合，在逻辑上需要很好的数学思维，希望能多思考一下，一定会有更多的收获，毕竟我们用了短短几行代码，就实现了加强版的 Promise-> Lazy Promise -> Task。</p>\n</blockquote>\n<blockquote>\n<p>更多的关于 Promise 和 Monad 的对比可以参考：<a href=\"https://www.breaktech.com/post/javascript-promises-and-monads\">Javascript: Promises and Monads</a>,<a href=\"https://glebbahmutov.com/blog/difference-between-promise-and-task/\">difference between promise and task</a></p>\n</blockquote>\n<h2>应用函子与单子</h2>\n<p>Monad 更擅长处理的是一种拥有 <code class=\"language-text\">Context(上下文)</code> 的场景，上面的 <code class=\"language-text\">getUser</code> 与 <code class=\"language-text\">getAge</code> 的例子中，<code class=\"language-text\">getAge</code> 函数必须等到 <code class=\"language-text\">getUser</code> 函数中的异步执行完成才能开始调用，这是一种<strong>纵向(串行)</strong>的链路；</p>\n<p>而<strong>Applicative更擅长的是处理一种横向(并行)的链路</strong>，比如上一章介绍的表单校验的例子，每个字段的校验之间完全没有什么关联关系。</p>\n<p>现在不禁要问 Task 可以实现异步的并行吗？答案是肯定的！假设 <code class=\"language-text\">getUser</code> 和 <code class=\"language-text\">getAge</code> 互不依赖，则完全可以采用 Applicative 的 apply 方法来进行组合。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">Task\n    <span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span> <span class=\"token operator\">=></span> <span class=\"token parameter\">age</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">,</span> age <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">ap</span><span class=\"token punctuation\">(</span>getUser<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">ap</span><span class=\"token punctuation\">(</span>getAge<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">fork</span><span class=\"token punctuation\">(</span>console<span class=\"token punctuation\">.</span>error<span class=\"token punctuation\">,</span> console<span class=\"token punctuation\">.</span>log<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 2000ms later， log： \"{name: 'Melo', age: 18}\"</span></code></pre></div>\n<blockquote>\n<p>Task.ap 可以参考 Promise.all 的原理，具体实现可以参考<a href=\"https://gist.github.com/Sylvenas/2a06088257344bc1596ed03407194f49\">gist.github</a>。</p>\n</blockquote>\n<h2>总结</h2>\n<ul>\n<li><code class=\"language-text\">Functor</code> 是一种实现 <code class=\"language-text\">map</code> 方法的数据类型</li>\n<li><code class=\"language-text\">Applicative</code> 是一种实现了 <code class=\"language-text\">apply</code> 方法的数据类型</li>\n<li><code class=\"language-text\">Monad</code> 是一种实现了 <code class=\"language-text\">chain</code> 或 <code class=\"language-text\">flatmap</code> 方法的数据类型</li>\n</ul>\n<p>那么<code class=\"language-text\">Functor</code>、<code class=\"language-text\">Applicative</code> 和 <code class=\"language-text\">Monad</code> 三个区别是什么？</p>\n<p><img src=\"https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/5502286847/c6d7/0597/c401/2284b7163900c63a298fbe46ce309e4d.png\" alt=\"functor-applicative-monad\"></p>\n<ul>\n<li><code class=\"language-text\">Functor</code>: 应用一个函数到包裹的值，使用 <code class=\"language-text\">map</code>.</li>\n<li><code class=\"language-text\">Applicative</code>: 应用一个包裹的函数到包裹的值，使用 <code class=\"language-text\">ap</code></li>\n<li><code class=\"language-text\">Monad</code>: 应用一个返回包裹值的函数到一个包裹的值，使用 <code class=\"language-text\">chain</code></li>\n</ul>\n<p>参考资料与引用文章：   </p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap\">Array.prototype.flatMap</a>     </li>\n<li><a href=\"https://www.youtube.com/watch?v=dkZFtimgAcM\">Monads and Gonads (YUIConf Evening Keynote)</a>   </li>\n<li><a href=\"https://jrsinclair.com/articles/2016/marvellously-mysterious-javascript-maybe-monad/\">Marvellously mysterious javascript maybe monad</a>   </li>\n<li><a href=\"https://medium.com/beingprofessional/understanding-functor-and-monad-with-a-bag-of-peanuts-8fa702b3f69e\">Understanding Functor and Monad With a Bag of Peanuts</a> </li>\n<li><a href=\"https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html\">Functors, Applicatives, And Monads In Pictures</a>     </li>\n<li><a href=\"http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html\">A Brief, Incomplete, and Mostly Wrong History of Programming Languages</a>     </li>\n<li><a href=\"https://jaysoo.ca/2016/01/13/functional-programming-little-ideas/\">The Little Idea of Functional Programming</a>    </li>\n<li><a href=\"https://github.com/fluture-js/Fluture/wiki/Comparison-to-Promises\">Comparison to Promises</a>    </li>\n<li><a href=\"https://medium.com/free-code-camp/functional-programming-in-js-with-practical-examples-part-2-429d2e8ccc9e\">Functional Programming In JavaScript — With Practical Examples</a>     </li>\n<li><a href=\"https://twitter.com/_ericelliott/status/905538090634059776\">Compose monads</a></li>\n<li><a href=\"https://blog.jcoglan.com/2011/03/05/translation-from-haskell-to-javascript-of-selected-portions-of-the-best-introduction-to-monads-ive-ever-read/\">Translation from Haskell to JavaScript of selected portions of the best introduction to monads I’ve ever read</a></li>\n<li><a href=\"https://blog.oyanglul.us/grokking-monad/part1\">猫论讲解monad</a></li>\n<li><a href=\"https://www.zhihu.com/question/24972880\">怎样用简单的语言解释 monad？</a></li>\n<li>《JavaScript函数式编程》   </li>\n</ul>\n<blockquote>\n<p>本文发布自 <a href=\"https://github.com/x-orpheus\">网易云音乐大前端团队</a>，文章未经授权禁止任何形式的转载。我们常年招收前端、iOS、Android，如果你准备换工作，又恰好喜欢云音乐，那就加入我们 grp.music-fe(at)corp.netease.com！</p>\n</blockquote>","frontmatter":{"title":"函数式编程进阶：Monad 与 异步函数的组合","date":"2021-01-19","description":"函数组合是函数式编程的核心，而「异步非阻塞」是 JavaScript 世界的主流；本篇文章将会介绍 Monad 的概念，以及如何优雅的实现异步函数的组合。"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/javascript-functional-programming-monad/","previous":{"fields":{"slug":"/flutter/"},"frontmatter":{"title":"Flutter 图片控件适配之路"}},"next":{"fields":{"slug":"/wkwebview/"},"frontmatter":{"title":"WKWebView 请求拦截探索与实践"}}}}}