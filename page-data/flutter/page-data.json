{"componentChunkName":"component---src-templates-blog-post-js","path":"/flutter/","webpackCompilationHash":"2f3c6da872df888e5c74","result":{"data":{"site":{"siteMetadata":{"title":"云音乐大前端专栏","author":"云音乐大前端团队","siteUrl":"https://musicfe.dev"}},"markdownRemark":{"id":"9fd7002f-574e-5ea6-b570-1da6dce210b4","excerpt":"本文作者：段家顺 背景 目前大部分应用都会使用大量的图片，图片成为当前应用带宽占比最大的一种资源。在我们接入 Flutter 的时候，发现 Flutter 的图片控件缓存完全由自己管理，同时还没有提供磁盘缓存（1.22版本），所以在性能以及体验上均比较差，所以必须对其进一步优化。 图片缓存 在目前很多 CDN…","html":"<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/5532178935/92d7/50a8/977d/4282554fe7a617d7fc4974724ba3e5b7.png\"></p>\n<blockquote>\n<p>本文作者：<a href=\"http://djs66256.github.io/\">段家顺</a></p>\n</blockquote>\n<h2>背景</h2>\n<p>目前大部分应用都会使用大量的图片，图片成为当前应用带宽占比最大的一种资源。在我们接入 Flutter 的时候，发现 Flutter 的图片控件缓存完全由自己管理，同时还没有提供磁盘缓存（1.22版本），所以在性能以及体验上均比较差，所以必须对其进一步优化。</p>\n<h2>图片缓存</h2>\n<p>在目前很多 CDN 实现上，所有资源都是拥有唯一 uri 的，所以很多的客户端实现，是忽略了 HTTP 协议中的 Caches 能力，而是直接将 uri 作为唯一标识符来判断图片资源是否唯一的。这样大大节省了向服务端确认 304 的时间与请求。</p>\n<p>而在客户端，一般都会存在至少<code class=\"language-text\">内存</code>和<code class=\"language-text\">磁盘</code>这两级缓存，而我们在接入 Flutter 图片库的时候，就希望能够将客户端的缓存与 Flutter 中的缓存进行打通，从而减少内存和网络的消耗。</p>\n<p>而目前复用缓存的方向大致有如下3种：</p>\n<ol>\n<li>复用视图，完全由客户端来提供 Flutter 的图片能力，就像 React Native 一样。</li>\n<li>复用磁盘缓存，不复用内存缓存，这种方案实现相对简单，但会导致内存中存在两份图片数据。</li>\n<li>复用内存缓存，由客户端从磁盘加载到内存，并由客户端来管理整个缓存的生命周期，比如和 SDWebImage 进行深度融合。该方案看似是最完美的复用，而且客户端有能力对整个应用的图片缓存大小进行精确的控制。</li>\n</ol>\n<p>那么下面我们来看看这几种方案的实现，哪些看似美好的方案，我们都踩了哪些坑。</p>\n<h2>复用视图</h2>\n<p>Flutter 提供了一种和客户端原生视图进行无缝拼接的方案，原始的动机其实是为了像地图、WebView 这种场景，Flutter 不可能再去实现一套如此复杂的控件。那么如果我们用这个来做客户端图片桥接方案会怎么样呢？</p>\n<p>首先，我们要明白 PlatformView 是如何进行桥接的（以下讨论的都是iOS实现）。在 Widget 中插入一层客户端 View，此时并不是我们想的那样，将此 View 简单的<code class=\"language-text\">draw</code>到 Flutter Root Layer 上。因为 Flutter 的<code class=\"language-text\">draw call</code>并不是发生在主线程上的，而是发生在<code class=\"language-text\">raster</code>线程上的，如果我们想要将客户端的 View 绘制到 Flutter 上，则必须先光栅化为一张图片，然后再进行绘制，这中间的性能开销与延迟显而易见是不可接受的，同时每帧都需要这么做也是不现实的。</p>\n<p>所以，Flutter 采用了一种拆分 Flutter Layer 的形式。在插入一个客户端 View 后，Flutter 会自动将自己拆为2层：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">|-----| Flutter Overlay View 2\n|-----| Native View\n|-----| Flutter Root View 1</code></pre></div>\n<p>客户端 View 就像夹心饼干一样被2个 Flutter view 夹住，此时位于 Platform View 上层以及后续的兄弟 Widget 都会被绘制到上层的 View 上，其他的依旧绘制在底层。这样虽然解决了客户端视图的接入，但也会导致一个问题，当上层视图发生位置等变更的时候，需要重新创建对应的 Overlay View，为了减少这种开销，Flutter 采用了一种比较 trick 的做法，即 Overlay View 会铺满屏幕，而通过移动上面的 mask 来进行控制展示区域。</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// The overlay view wrapper masks the overlay view.</span>\n<span class=\"token comment\">// This is required to keep the backing surface size unchanged between frames.</span>\n<span class=\"token comment\">//</span>\n<span class=\"token comment\">// Otherwise, changing the size of the overlay would require a new surface,</span>\n<span class=\"token comment\">// which can be very expensive.</span>\n<span class=\"token comment\">//</span>\n<span class=\"token comment\">// This is the case of an animation in which the overlay size is changing in every frame.</span>\n<span class=\"token comment\">//</span>\n<span class=\"token comment\">// +------------------------+</span>\n<span class=\"token comment\">// |   overlay_view         |</span>\n<span class=\"token comment\">// |    +--------------+    |              +--------------+</span>\n<span class=\"token comment\">// |    |    wrapper   |    |  == mask =>  | overlay_view |</span>\n<span class=\"token comment\">// |    +--------------+    |              +--------------+</span>\n<span class=\"token comment\">// +------------------------+</span></code></pre></div>\n<p>目前已经解决了客户端视图接入 Flutter 的能力，但可以看到，当插入一张客户端 View，Flutter 需要额外创建2个 View 进行分区域绘制。当一个页面存在多张图片的时候，此时额外产生的开销显然也是不可接受的，性能更是不可接受。</p>\n<p>下面是 Flutter 官方在 Platform View 上描述的关于性能的考虑。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Platform views in Flutter come with performance trade-offs.\n\nFor example, in a typical Flutter app, the Flutter UI is composed on a dedicated raster thread. This allows Flutter apps to be fast, as the main platform thread is rarely blocked.\n\nWhile a platform view is rendered with Hybrid composition, the Flutter UI is composed from the platform thread, which competes with other tasks like handling OS or plugin messages, etc.\n\nPrior to Android 10, Hybrid composition copies each Flutter frame out of the graphic memory into main memory, and then copies it back to a GPU texture. In Android 10 or above, the graphics memory is copied twice. As this copy happens per frame, the performance of the entire Flutter UI may be impacted.\n\nVirtual display, on the other hand, makes each pixel of the native view flow through additional intermediate graphic buffers, which cost graphic memory and drawing performance.</code></pre></div>\n<h2>复用磁盘缓存</h2>\n<p>让我们都退一步，我们首先解决网络带宽的问题，那么一个简单的方案便是复用磁盘缓存。</p>\n<p>复用磁盘缓存的方案相对可以做的非常简单，并且拥有极低的侵入性。我们只需要设计一套 channel 接口，来同步双方缓存的状态和缓存的地址。</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token function\">getCacheInfo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> \n    String url<span class=\"token punctuation\">,</span>\n    double width<span class=\"token punctuation\">,</span>\n    double height<span class=\"token punctuation\">,</span>\n    double scale<span class=\"token punctuation\">,</span>\n    BoxFit fit<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> \n<span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>String path<span class=\"token punctuation\">,</span> bool exists<span class=\"token punctuation\">}</span></code></pre></div>\n<p>那么在使用的时候，我们仅需要定制一套新的 ImageProvider，将网络、本地两种 Provider 统一起来即可。</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token function\">_CompositeImageStreamCompleter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    String url<span class=\"token punctuation\">,</span>\n    double width<span class=\"token punctuation\">,</span>\n    double height\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">getCacheInfo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>url<span class=\"token punctuation\">:</span> url<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">:</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">:</span>height<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>info<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>info <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> info<span class=\"token punctuation\">.</span>path <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> info<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> imageProvider<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">var</span> decode <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>decode<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>info<span class=\"token punctuation\">.</span>exists<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">final</span> imageFile <span class=\"token operator\">=</span> <span class=\"token function\">File</span><span class=\"token punctuation\">(</span>info<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            imageProvider <span class=\"token operator\">=</span> <span class=\"token function\">FileImage</span><span class=\"token punctuation\">(</span>imageFile<span class=\"token punctuation\">,</span> scale<span class=\"token punctuation\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>scale<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            imageProvider <span class=\"token operator\">=</span> <span class=\"token function\">NetworkImage</span><span class=\"token punctuation\">(</span>info<span class=\"token punctuation\">.</span>fixUrl <span class=\"token operator\">?</span><span class=\"token operator\">?</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">,</span>\n                scale<span class=\"token punctuation\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>scale<span class=\"token punctuation\">,</span> headers<span class=\"token punctuation\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>headers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            decode <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Uint8List bytes<span class=\"token punctuation\">,</span>\n                <span class=\"token punctuation\">{</span>int cacheWidth<span class=\"token punctuation\">,</span> int cacheHeight<span class=\"token punctuation\">,</span> bool allowUpscaling<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">final</span> cacheFile <span class=\"token operator\">=</span> <span class=\"token function\">File</span><span class=\"token punctuation\">(</span>info<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// 缓存到磁盘</span>\n            cacheFile<span class=\"token punctuation\">.</span><span class=\"token function\">writeAsBytes</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">decode</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">,</span>\n                cacheWidth<span class=\"token punctuation\">:</span> cacheWidth<span class=\"token punctuation\">,</span>\n                cacheHeight<span class=\"token punctuation\">:</span> cacheHeight<span class=\"token punctuation\">,</span>\n                allowUpscaling<span class=\"token punctuation\">:</span> allowUpscaling<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        _childCompleter <span class=\"token operator\">=</span> imageProvider<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span>imageProvider<span class=\"token punctuation\">,</span> decode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">final</span> listener <span class=\"token operator\">=</span>\n            <span class=\"token function\">ImageStreamListener</span><span class=\"token punctuation\">(</span>_onImage<span class=\"token punctuation\">,</span> onChunk<span class=\"token punctuation\">:</span> _onChunk<span class=\"token punctuation\">,</span> onError<span class=\"token punctuation\">:</span> _onError<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        _childCompleter<span class=\"token punctuation\">.</span><span class=\"token function\">addListener</span><span class=\"token punctuation\">(</span>listener<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">catchError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">,</span> stack<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">print</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里需要注意的是，当不存在磁盘缓存的时候，这里采用了 Flutter 来下载图片，此时需要我们手动将其保存到磁盘上，以保证磁盘缓存的一致性。</p>\n<h2>复用内存缓存</h2>\n<p>复用磁盘缓存是风险较低的一种改动，但是代价是无法复用内存缓存，不仅仅需要分别读取，同时会保存多份内存缓存，因为双方的内存缓存部分是完全独立存在的。</p>\n<p>那么如果我们想进一步优化，则需要采用复用内存缓存的方案，目前同步内存缓存大致有如下几种方案：</p>\n<ul>\n<li>利用 channel 通信，将内存传输给 Flutter</li>\n<li>利用新特性 ffi 通道，将内存直接传递给 Flutter</li>\n<li>利用 Texture 控件，从纹理层面进行复用</li>\n</ul>\n<h3>Channel</h3>\n<p>Flutter 官方稳定的消息通信方案，兼容性和稳定性都非常高。当我们需要展示缓存图片的时候，只需要将图片数据通过 BinaryMessenger 形式传递到 Flutter 即可。</p>\n<p>由于 Channel 本身就必须是异步过程，所以该方式通信会有一定开销。</p>\n<p>同时由于 Channel 在客户端是在主线程进行处理，所以也需要注意避免在主线程直接做加载与解码等耗时操作。</p>\n<p>而 Channel 在数据传递过程中，由于机制（从安全角度来看也必须这么做）原因，二进制数据必然会被拷贝一份，这样导致的结果是 Flutter 这边维护的内存缓存和客户端自身的缓存依然是两份，并没有完美的达到我们上述的复用效果。</p>\n<h3>ffi</h3>\n<p>从消息通信开销以及消息的内存拷贝问题来看，ffi 的出现似乎能够完美解决 Channel 中所有的问题。</p>\n<p>原理和实现过程与 Channel 完全一致，此时只需要替换为 ffi 通道即可。ffi 并没有像 Channel 那么长的通信过程，不需要进行消息序列化与解析，也不需要切换线程处理，就像一个 HTTP 请求和一个简单的 API 调用的区别一样。</p>\n<p>这里我们需要注意的是 ffi 接口是同步执行的，也就是说客户端执行的时候是处于 flutter.ui 线程，我们必须注意线程安全问题。而对于 Flutter 来说，由于是在 UI 线程执行，所以该方法必须尽量快的返回，不能执行一些耗时比较长的操作。</p>\n<p>但是我们采用 ffi 就真的能够解决上述问题吗？仔细研究发现，其实还是不能解决内存复用的根本性问题，下面可以看下 ffi 转换的过程。</p>\n<p>当我们把客户端图片加载到内存的时候，是通过 Buffer 的形式传递给 Flutter 的，比如是这样一个结构：</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">struct Buffer {\n    int8    *ptr;\n    size_t  length;\n}</code></pre></div>\n<p>对应于 Dart 中的数据类型为<code class=\"language-text\">Int8Pointer</code>和<code class=\"language-text\">Int64</code>，而 Image 控件所需要的数据类型为<code class=\"language-text\">Uint8List</code>，那么我们必须进行一步数据格式转换：</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\">Pointer<span class=\"token operator\">&lt;</span>UInt8<span class=\"token operator\">></span> bufferPtr<span class=\"token punctuation\">;</span>\nint length<span class=\"token punctuation\">;</span>\nUint8List buffer <span class=\"token operator\">=</span> bufferPtr<span class=\"token punctuation\">.</span><span class=\"token function\">asTypedList</span><span class=\"token punctuation\">(</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>而在这次转换过程中，会发生一次内存拷贝(Uint8List 底层保持数据使用的是 std::vector)。</p>\n<p>所以，从最终结果来看，并不比 Channel 有更高的缓存复用能力。</p>\n<h3>Texture</h3>\n<p>另一种是共享 PixelBuffer，也就是解码后的图片数据，在 Flutter 这里可以采用 Texture 来实现复用。</p>\n<p>具体实现方案阿里已经研究的非常透彻，这里就不再复述了，我们主要分析下其性能与复用能力。</p>\n<p>Texture 复用采用的是 TextureId，这是一个 int 值，所以在两端通信上不存在数据量上的性能开销。其主要过程是：</p>\n<ol>\n<li>客户端将纹理注册到 Flutter，同时会返回一个 id 作为唯一标识符（i++）。这个过程发生在 Platform 线程，也就是客户端主线程，而真正注册到 TextureRegistry 中则是在 raster 线程中完成的。</li>\n<li>在 flutter.ui 线程处理 paint 事件的时候，会将该 id 传递给 TextureLayer。</li>\n<li>并在 raster 线程，凭借 TextureId 从 TextureRegistry 中取出并生成 draw call。</li>\n</ol>\n<p>从整体流程来看，Flutter 在中间流转过程全程只使用了 TextureId，并不会操作内存与纹理，并不存在多份缓存的问题。所以这种方案比较完美的解决了上述两个问题。</p>\n<h2>内存优化</h2>\n<p>虽然从上述分析中，缓存利用率最高的是 Texture，但是从内存上来分析，则出现了一个意想不到的结果。</p>\n<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/5532110701/8410/a6fc/418a/3b693186cef4cbfa76ecbb9211f7ff32.png\"></p>\n<p>上图是使用 Flutter Image 控件，加载几张大图的一个内存图，总共增加了 10M 内存消耗。</p>\n<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/5532110704/ebb7/6fb1/8ff7/eea729811b6b884184dda4dbac9df749.png\"></p>\n<p>上图是使用 Texture 方案，加载同样图片所产生的内存消耗，达到了 37M，相差巨大。</p>\n<p>同时可以看到原生 Flutter 图片在初始阶段有一个比较大的波峰，同样纹理也有，但相对平缓一些。</p>\n<p>产生这样大的区别主要还是要从 Flutter Image 控件的渲染流程中说起。</p>\n<ol>\n<li>ImageProvider 将图片加载到内存后，首先会进行解码，而这个事情是在 flutter.io 线程完成的。</li>\n<li>图片数据解码之后，会造成一个非常大的内存消耗，因为此时的图片数据是以 pixel buffer 的形式存储的。而 Flutter 在这一过程会进行一个优化，此时解码的数据将不是 100% 大小的，而是会当前 widget size进行调整，计算出一个最优的大小，然后在这一大小上进行解码，所以原生的 Image 反而在内存占用这个方面会比客户端更优秀。</li>\n<li>在图片移除后，Flutter 会立刻回收解码后的内存，即 Flutter 仅对图片的原始压缩数据进行存储，并不缓存 pixel buffer。而我们客户端（SDWebImage）则会缓存解码后的全部数据，这也是另一个 Flutter 内存表现比客户端要优的地方。</li>\n</ol>\n<p>那么 Flutter 这种策略在内存占用上完胜客户端，是否就必然是好的呢？</p>\n<p>其实从渲染流程中看，Flutter 仅仅是用解码时间换取了内存空间。在实际 Demo 中，列表快速滑动时，Flutter Image 控件的图片展示会有明显的延迟，而采用 Texture 方案，肉眼几乎无法分辨。所以从整体的表现上来说，Texture 方案并不是没有优点。</p>\n<h2>图片尺寸</h2>\n<p>从上述中可以看出来，Texture 方案在内存的表现上比较差，那么我们如何去进一步优化呢？</p>\n<p>对于很多场景，比如用户头像等，都是有一个固定大小的，那么我们可以将该大小作为参数，传给 CDN，在 CDN 上就进行裁剪成我们需要的大小，这样也会节省大量流量。</p>\n<p>但是同样有很多场景，我们是无法得到其控件大小的，比如充满容器大小这种场景。我们如何自动在所有图片上加上 Size 参数呢？</p>\n<p>从渲染过程中，<code class=\"language-text\">Layout</code>之后会触发<code class=\"language-text\">Paint</code>，而此时该控件的大小必然已经是完全确定的了，那么我们可以在这里做一个假的占位控件，在计算出大小后，再替换为真正的图片。</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">typedef</span> ImageSizeResolve <span class=\"token operator\">=</span> <span class=\"token keyword\">void</span> <span class=\"token function\">Function</span><span class=\"token punctuation\">(</span>Size size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ImageSizeProxyWidget</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">SingleChildRenderObjectWidget</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token function\">ImageSizeProxyWidget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>Key key<span class=\"token punctuation\">,</span> Widget child<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>onResolve<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">:</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">:</span> key<span class=\"token punctuation\">,</span> child<span class=\"token punctuation\">:</span> child<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">final</span> ImageSizeResolve onResolve<span class=\"token punctuation\">;</span>\n\n  <span class=\"token metadata symbol\">@override</span>\n  ImageSizeProxyElement <span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">ImageSizeProxyElement</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token metadata symbol\">@override</span>\n  ImageSizeRenderBox <span class=\"token function\">createRenderObject</span><span class=\"token punctuation\">(</span>BuildContext context<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span>\n      <span class=\"token function\">ImageSizeRenderBox</span><span class=\"token punctuation\">(</span>onResolve<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token metadata symbol\">@override</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">updateRenderObject</span><span class=\"token punctuation\">(</span>\n      BuildContext context<span class=\"token punctuation\">,</span> covariant ImageSizeRenderBox renderObject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">updateRenderObject</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> renderObject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    renderObject<span class=\"token punctuation\">.</span>onResolve <span class=\"token operator\">=</span> onResolve<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ImageSizeProxyElement</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">SingleChildRenderObjectElement</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">ImageSizeProxyElement</span><span class=\"token punctuation\">(</span>RenderObjectWidget widget<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>widget<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ImageSizeRenderBox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">RenderProxyBox</span> <span class=\"token keyword\">with</span> RenderProxyBoxMixin <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">ImageSizeRenderBox</span><span class=\"token punctuation\">(</span>ImageSizeResolve onResolve<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>RenderBox child<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">:</span> onResolve <span class=\"token operator\">=</span> onResolve<span class=\"token punctuation\">,</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  ImageSizeResolve onResolve<span class=\"token punctuation\">;</span>\n\n  <span class=\"token metadata symbol\">@override</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">paint</span><span class=\"token punctuation\">(</span>PaintingContext context<span class=\"token punctuation\">,</span> ui<span class=\"token punctuation\">.</span>Offset offset<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hasSize<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>onResolve <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token function\">onResolve</span><span class=\"token punctuation\">(</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">paint</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这样，我们就能强制所有图片都必须带上 Size 参数了。</p>\n<p><img src=\"https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/5532110693/6167/5c83/1298/24f2dfd9327f1f94372af2e67dd2c3dd.png\"></p>\n<p>经过这样的优化处理后，内存占用下降到了 2M 左右（由于我用的测试图都是高清图，所以效果看上去会比较明显）。</p>\n<h2>总结</h2>\n<p>Flutter 的很多思路和策略和客户端有着明显的区别，从图片这一个能力来看，就可以从各个方面进行适配与优化，如果需要达到完美可用的一个状态，看来还是需要不断的投入与探索。</p>\n<h2>附录</h2>\n<p>Texture 实现方案可以参考<a href=\"https://zhuanlan.zhihu.com/p/102990945\">《Alibaba.com Flutter 探索之路：Flutter 图片性能优化》</a>。</p>\n<blockquote>\n<p>本文发布自 <a href=\"https://github.com/x-orpheus\">网易云音乐大前端团队</a>，文章未经授权禁止任何形式的转载。我们常年招收前端、iOS、Android，如果你准备换工作，又恰好喜欢云音乐，那就加入我们 grp.music-fe(at)corp.netease.com！</p>\n</blockquote>","frontmatter":{"title":"Flutter 图片控件适配之路","date":"2021-01-13","description":"在我们接入 Flutter 技术的时候，必然会用到大量的图片，本文将讨论构建一个图片控件的方案与优化过程。"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/flutter/","previous":{"fields":{"slug":"/lottie-web/"},"frontmatter":{"title":"剖析 lottie-web 动画实现原理"}},"next":{"fields":{"slug":"/javascript-functional-programming-monad/"},"frontmatter":{"title":"函数式编程进阶：Monad 与 异步函数的组合"}}}}}