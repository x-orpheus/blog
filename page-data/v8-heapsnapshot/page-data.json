{"componentChunkName":"component---src-templates-blog-post-js","path":"/v8-heapsnapshot/","webpackCompilationHash":"2f3c6da872df888e5c74","result":{"data":{"site":{"siteMetadata":{"title":"云音乐大前端专栏","author":"云音乐大前端团队","siteUrl":"https://musicfe.dev"}},"markdownRemark":{"id":"1c07702b-e7f6-5931-b414-19c9f5ebafa4","excerpt":"图片来源：debugging-memory-leaks-node-js-applications 本文作者：肖思元 在 node 中可以通过 v8.getHeapSnapshot…","html":"<p><img src=\"https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7840186783/2208/9c86/ee29/7eed5a369fd9cfc6470d464abeb7fca5.png\"></p>\n<blockquote>\n<p>图片来源：<a href=\"https://www.toptal.com/nodejs/debugging-memory-leaks-node-js-applications\">debugging-memory-leaks-node-js-applications</a></p>\n</blockquote>\n<blockquote>\n<p>本文作者：<a href=\"https://github.com/hsiaosiyuan0\">肖思元</a></p>\n</blockquote>\n<p>在 node 中可以通过 <a href=\"https://nodejs.org/api/v8.html#v8_v8_getheapsnapshot\">v8.getHeapSnapshot</a> 来获取应用当前的堆快照信息，该调用会生成一份 <code class=\"language-text\">.heapsnapshot</code> 文件，官方并没有对该文件的内容有一个详细的解释，本文将主要对该文件内容进行解析，并演示了一个了解文件内容后可以做的有趣的事情</p>\n<h2>v8.getHeapSnapshot</h2>\n<p>首先简单回顾下 <code class=\"language-text\">v8.getHeapSnapshot</code> 是如何使用的：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// test.js</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> writeHeapSnapshot <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"v8\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">HugeObj</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>hugeData <span class=\"token operator\">=</span> Buffer<span class=\"token punctuation\">.</span><span class=\"token function\">alloc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 注意下面的用法在实际应用中通常是 anti-pattern，</span>\n<span class=\"token comment\">// 这里只是为了方便演示，才将对象挂到 module 上以防止被 GC 释放</span>\nmodule<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">.</span>data <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HugeObj</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">writeHeapSnapshot</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>将上面的代码保存到 <code class=\"language-text\">test.js</code> 中，然后运行 <code class=\"language-text\">node test.js</code>，会生成文件名类似 <code class=\"language-text\">Heap.20210228.154141.9320.0.001.heapsnapshot</code> 的文件，该文件可以使用 <a href=\"https://developers.google.com/web/tools/chrome-devtools\">Chrome Dev Tools</a> 进行查看</p>\n<blockquote>\n<p>对于上面的步骤我们也可以直接 <a href=\"https://musicfe.nos-jd.163yun.com/8eaba450-ff7b-4401-b307-8aa69a57c582.mp4\">查看视频演示</a></p>\n</blockquote>\n<p>当我们将 <code class=\"language-text\">.heapsnapshot</code> 文件导入到 Chrome Dev Tools 之后，我们会看到类似下面的内容：</p>\n<p><img src=\"https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7812327984/da1e/748d/869a/8b718377c7a767895fd9d5410e601aae.png\"></p>\n<p>上图表格列出了当前堆中的所有对象，其中列的含义是：</p>\n<ul>\n<li>Constructor，表示对象是使用该函数构造而来</li>\n<li>Constructor 对应的实例的数量，在 Constructor 后面的 <code class=\"language-text\">x2</code> 中显示</li>\n<li>\n<p>Shallow size，对象自身大小（单位是 Byte），比如上面的 <code class=\"language-text\">HugeObj</code>，它的实例的 Shallow size 就是自身占用的内存大小，比如，对象内部为了维护属性和值的对应关系所占用的内存，并不包含持有对象的大小</p>\n<p>比如 <code class=\"language-text\">hugeData</code> 属性引用的 <code class=\"language-text\">Buffer</code> 对象的大小，并不会计算在 <code class=\"language-text\">HugeObj</code> 实例的 Shallow size 中</p>\n</li>\n<li>Retained size，对象自身大小加上它依赖链路上的所有对象的自身大小（Shallow size）之和</li>\n<li>Distance，表示从根节点（Roots）到达该对象经过的最短路径的长度</li>\n</ul>\n<h2>heapsnapshot 文件</h2>\n<p>Chrome Dev Tools 只是 <code class=\"language-text\">.heapsnapshot</code> 文件的一种展现形式，如果我们希望最大程度利用这些信息，则需要进一步了解其文件格式</p>\n<p>我们可以使用任意的文本编辑器打开该文件，可以发现文件内容其实是 JSON 格式的：</p>\n<p><img src=\"https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7812727100/e0fb/c34a/de03/6ecf5b8a52040c4de57006c4682c7ed3.png\"></p>\n<p>因为目前没有具体的说明文档，后面的内容我们将结合源码来分析该文件的内容</p>\n<h2>文件内容概览</h2>\n<p>在原始输出的文件内容中，可以发现 <code class=\"language-text\">snapshot</code> 字段部分是去除空白的，而 <code class=\"language-text\">nodes</code> 和 <code class=\"language-text\">edges</code> 字段的内容都是有换行分隔的，整体文件有非常多的行数</p>\n<p>为了方便理解，我们可以将节点折叠，这样可以看出该文件的整体内容：</p>\n<p><img src=\"https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7812751100/a7a4/9e92/a1ef/0d8e594dc6d6672b0c84a2810d77ff68.png\"></p>\n<p>随后我们在源码中，以该 <code class=\"language-text\">v8.getHeapSnapshot</code> 的 <code class=\"language-text\">binding</code> 着手，定位到该文件内容是方法 <a href=\"https://github.com/nodejs/node/blob/v14.x/deps/v8/src/profiler/heap-snapshot-generator.cc#L2027\">HeapSnapshotGenerator::GenerateSnapshot</a> 的运行结果</p>\n<p>并且我们知道对象在内存中的拓扑形式需要使用 <a href=\"https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/\">Graph 数据结构</a> 来表示，因此输出文件中有 <code class=\"language-text\">nodes</code> 和 <code class=\"language-text\">edges</code> 字段分别用于表示堆中的对象，以及对象间的连接关系：</p>\n<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7812905466/70a8/2f14/2e84/bf9a2eb0f2232a0637207bbb2267efe9.png\"></p>\n<blockquote>\n<p>图片引用自 <a href=\"https://guides.codepath.com/compsci/Graphs\">Graphs\n</a></p>\n</blockquote>\n<p>不过 <code class=\"language-text\">nodes</code> 和 <code class=\"language-text\">edges</code> 中并没有直接存储对象的信息，而都是一连串数字，我们需要进一步分析其中的内容</p>\n<h3>nodes</h3>\n<p>nodes 中的每一个 Node 的序列化方法是：<a href=\"https://github.com/nodejs/node/blob/v14.x/deps/v8/src/profiler/heap-snapshot-generator.cc#L2344\">HeapSnapshotJSONSerializer::SerializeNode</a></p>\n<p>从源码来看，每输出完 node 的所有属性值后，会跟着输出 <code class=\"language-text\">\\n\\0</code>，这也是输出结果中 <code class=\"language-text\">nodes</code> 数组是一行行数字的原因。不过我们知道 <code class=\"language-text\">\\n\\0</code> 在 JSON 反序列化的时候因为会因为自身符合空白的定义而被忽略掉，所以这样的换行可以理解是为了方便直接查看源文件</p>\n<p>我们来看一个例子，比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n<span class=\"token property\">\"nodes\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">[</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span> <span class=\"token comment\">// 第一行</span>\n<span class=\"token punctuation\">,</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">23</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span>         <span class=\"token comment\">// 第二行</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的内容，每行分别表示一个 node，每一行都是对象的属性的 <code class=\"language-text\">value</code>（我们先不用考虑为什么 value 都是数值）。而属性的 <code class=\"language-text\">name</code> 我们通过源码中输出的顺序可以整理出来：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">0. type\n1. name\n2. id\n3. self_size\n4. edge_count\n5. trace_node_id</code></pre></div>\n<p>因为 <code class=\"language-text\">value</code> 的输出顺序和上面的 <code class=\"language-text\">name</code> 是对应的，所以我们可以根据属性 <code class=\"language-text\">name</code> 的顺序作为索引，去关联其 <code class=\"language-text\">value</code> 的值</p>\n<p>不过实际上并不能省略属性名称列表的输出，因为属性的内容是可能在后续的 node 版本中变化的（主要是跟随 v8 的变化），为了和对应的数据消费端解耦，文件中会将属性 <code class=\"language-text\">name</code> 列出输出，保存在 <code class=\"language-text\">snapshot.meta.node_fields</code> 中</p>\n<h3>Field Type</h3>\n<p>接下来我们来看为什么 nodes 数组保存的属性 value 都是数值</p>\n<p>还是上面的例子，因为我们已经知道了，属性名称和属性值是按索引顺序对应上的，那么对于上面第一个 node 的 <code class=\"language-text\">propertyName(propertyValue)</code> 列表可以表示为：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">0. type(9)\n1. name(1)\n2. id(1)\n3. self_size(0)\n4. edge_count(10)\n5. trace_node_id(0)</code></pre></div>\n<p>比如第 1 号属性 <code class=\"language-text\">name</code>，它就是对象的名称，不过根据对象的类型不同，该值也会有不同的取值方式。比如对于一般对象而言，它的内容就是其构造函数的名称，对于 Regexp 对象而言，它的值就是 <code class=\"language-text\">pattern</code> 字符串，更多得可以参考 <a href=\"https://github.com/nodejs/node/blob/master/deps/v8/src/profiler/heap-snapshot-generator.cc#L587\">V8HeapExplorer::AddEntry</a></p>\n<p>假如我们直接保存属性的值，那么如果堆中有 1000 个由 <code class=\"language-text\">HugeObj</code> 构造的对象，<code class=\"language-text\">HugeObj</code> 字符串就要保存 1000 个拷贝</p>\n<p>因为 heapdump 顾名思义，输出大小几乎就和当前 Node 应用所占内存大小一致（并不完全一致，这里 heapdump 只包含受 GC 管理的内容），为了让输出的结果尽可能的紧凑，v8 在输出属性值的时候，按一定的规则进行了压缩，压缩的秘诀是：</p>\n<ul>\n<li>增加一条记录 <code class=\"language-text\">snapshot.meta.node_types</code>，来存放属性的类型，和 <code class=\"language-text\">snapshot.meta.node_fields</code> 类似，它们和属性值之间也是通过索引（顺序）关联的</li>\n<li>\n<p><code class=\"language-text\">nodes</code> 中只存放属性值，我们需要计算一下偏移量（下面会讲到），来确定属性的类型：</p>\n<ul>\n<li>如果是数值类型，那么该值就是本身的内容</li>\n<li>如果是数组，则 value 对应数组中的索引</li>\n<li>如果是字符串，则 value 对应 <code class=\"language-text\">strings</code> 数组的内容</li>\n</ul>\n</li>\n</ul>\n<p>我们可以用下面的图来表示三者之间的关系：</p>\n<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7814264688/4239/09c1/ddef/d80baf4f620f2c84a358522f3d3533b3.png\"></p>\n<p>我们通过一个例子来串联上面的内容。比如我们要看索引为 1000 的对象（注意区别 <code class=\"language-text\">id</code> 属性）的 <code class=\"language-text\">name</code> 属性的值，使用下面的方式：</p>\n<ul>\n<li>取 <code class=\"language-text\">name</code> 属性在 <code class=\"language-text\">snapshot.meta.node_fields</code> 中的索引为 <code class=\"language-text\">1</code></li>\n<li>取 <code class=\"language-text\">snapshot.meta.node_fields</code> 数组的长度为 <code class=\"language-text\">6</code></li>\n<li>则索引为 1000 的对象的起始索引为：<code class=\"language-text\">1000 * 6</code>（因为对象属性的数量是固定的）</li>\n<li>加上 <code class=\"language-text\">name</code> 属性的偏移量 <code class=\"language-text\">1</code>，则 <code class=\"language-text\">name</code> 在 <code class=\"language-text\">nodes</code> 数组中的索引为 <code class=\"language-text\">6001 = 1000 * 6 + 1</code></li>\n<li>取 <code class=\"language-text\">name</code> 属性在 <code class=\"language-text\">snapshot.meta.node_types</code> 中的类型，即 <code class=\"language-text\">snapshot.meta.node_types[1]</code>，在这个例子中是 <code class=\"language-text\">string</code></li>\n<li>则 <code class=\"language-text\">strings[6001]</code> 的内容就是 <code class=\"language-text\">name</code> 属性值的最终内容</li>\n</ul>\n<p>其余一些字段的含义是：</p>\n<ul>\n<li>id，对象的 id，v8 会确保该对象在本次应用生命周期中的多次的 dump 下中保持相同的 id</li>\n<li>self_size，也就是上文提到的 shallow size</li>\n<li>edge_count，就是从该对象出去的边的条数，也就是子对象的数量</li>\n<li>trace<em>node</em>id，可以暂时不去考虑，只有在同时使用 <code class=\"language-text\">node --track-heap-objects</code> 启动应用的情况下，该内容才不会为 <code class=\"language-text\">0</code>。它可以结合 <code class=\"language-text\">trace_tree</code> 和 <code class=\"language-text\">trace_function_infos</code> 一起知道对象是在什么调用栈下被创建的，换句话说就是知道经过一系列什么调用创了该对象。文本不会讨论这部分内容，或许会在以后的章节中展开</li>\n</ul>\n<h3>edges</h3>\n<p>edges 中的 Edge 的序列化方式是：<a href=\"https://github.com/nodejs/node/blob/v14.x/deps/v8/src/profiler/heap-snapshot-generator.cc#L2311\">HeapSnapshotJSONSerializer::SerializeEdge</a></p>\n<p>字段内容分别是：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">0. type\n1. edge_name_or_index(idx or stringId)\n2. to</code></pre></div>\n<p>和上面的 nodes 数组类似，edges 数组也是都存的属性的值，因此在取最终值的时候，需要结合 <code class=\"language-text\">snapshot.meta.edge_fields</code> <code class=\"language-text\">snapshot.meta.edge_types</code> 来操作</p>\n<p>唯一的问题在于，我们知道 Edge 表示的对象之间的关系，而且这里是有向图，那么一定有 <code class=\"language-text\">From</code> 和 <code class=\"language-text\">To</code> 两个字段，而上面的字段内容只有 <code class=\"language-text\">To</code>，那么 nodes 和 edges 是如何对应的呢？</p>\n<h3>Node 和 Edge 的对应关系</h3>\n<p>从头以 <a href=\"https://github.com/nodejs/node/blob/v14.x/deps/v8/src/profiler/heap-snapshot-generator.cc#L2027\">HeapSnapshotGenerator::GenerateSnapshot</a> 方法开始分析，看看 nodes 和 edges 是如何产生的，下面是该方法中的相关主要内容：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">bool</span> HeapSnapshotGenerator<span class=\"token operator\">::</span><span class=\"token function\">GenerateSnapshot</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n\n  <span class=\"token comment\">// 加入 Root 节点，作为活动对象的起点</span>\n  snapshot_<span class=\"token operator\">-></span><span class=\"token function\">AddSyntheticRootEntries</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 即 HeapSnapshotGenerator::FillReferences 方法，nodes 和 edges</span>\n  <span class=\"token comment\">// 都是由该方法构建的，这里的 nodes 和 edges 指的是 HeapSnapshot 的</span>\n  <span class=\"token comment\">// 数据成员 `entries_` 和 `edges_`</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">FillReferences</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 输出文件中的 edges 实际是通过 `FillChildren` 重新组织顺序的，</span>\n  <span class=\"token comment\">// 重新组织后的内容保存在 HeapSnapshot 的数据成员 children_ 中</span>\n  snapshot_<span class=\"token operator\">-></span><span class=\"token function\">FillChildren</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  snapshot_<span class=\"token operator\">-></span><span class=\"token function\">RememberLastJSObjectId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  progress_counter_ <span class=\"token operator\">=</span> progress_total_<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">ProgressReport</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>可以暂时不去深入了解 Node 和 Edge 是如何生成的，看一下 <a href=\"https://github.com/nodejs/node/blob/v14.x/deps/v8/src/profiler/heap-snapshot-generator.cc#L252\">HeapSnapshot::FillChildren</a> 方法是如何重新组织输出的 edges 内容的：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">void</span> HeapSnapshot<span class=\"token operator\">::</span><span class=\"token function\">FillChildren</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token keyword\">int</span> children_index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>HeapEntry<span class=\"token operator\">&amp;</span> entry <span class=\"token operator\">:</span> <span class=\"token function\">entries</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    children_index <span class=\"token operator\">=</span> entry<span class=\"token punctuation\">.</span><span class=\"token function\">set_children_index</span><span class=\"token punctuation\">(</span>children_index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token function\">children</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">resize</span><span class=\"token punctuation\">(</span><span class=\"token function\">edges</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>HeapGraphEdge<span class=\"token operator\">&amp;</span> edge <span class=\"token operator\">:</span> <span class=\"token function\">edges</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    edge<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token function\">add_child</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>edge<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>其中 <code class=\"language-text\">entry.set_children_index</code> 和 <code class=\"language-text\">edge.from()-&gt;add_child</code> 方法内容分别是：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> HeapEntry<span class=\"token operator\">::</span><span class=\"token function\">set_children_index</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Note: children_count_ and children_end_index_ are parts of a union.</span>\n  <span class=\"token keyword\">int</span> next_index <span class=\"token operator\">=</span> index <span class=\"token operator\">+</span> children_count_<span class=\"token punctuation\">;</span>\n  children_end_index_ <span class=\"token operator\">=</span> index<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> next_index<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> HeapEntry<span class=\"token operator\">::</span><span class=\"token function\">add_child</span><span class=\"token punctuation\">(</span>HeapGraphEdge<span class=\"token operator\">*</span> edge<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  snapshot_<span class=\"token operator\">-></span><span class=\"token function\">children</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span>children_end_index_<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> edge<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>所以对于每个 entry（即 node）都有一个属性 <code class=\"language-text\">children_index</code>，它表示 entry 的 children 在 <code class=\"language-text\">children_</code> 数组中的起始索引（上面注释中已经提到，heapsnapshot 文件中的 <code class=\"language-text\">edges</code> 数组的内容就是根据 <code class=\"language-text\">children_</code> 数组输出的）</p>\n<p>综合来看，<code class=\"language-text\">edges</code> 数组的内容和 <code class=\"language-text\">nodes</code> 之间的对应关系大致是：</p>\n<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7814657666/5104/b17d/faf0/c7d6c6432b156c51b8ea0f9e842321cc.png\"></p>\n<p>比如上面 <code class=\"language-text\">edge0</code> 的 <code class=\"language-text\">From</code> 就是 <code class=\"language-text\">nodes[0 + 2]</code>，其中：</p>\n<ul>\n<li><code class=\"language-text\">nodes</code> 表示 nodes 数组</li>\n<li><code class=\"language-text\">0</code> 的位置表示该 node 在 <code class=\"language-text\">nodes</code> 数组中的索引，这里也就是第一个元素</li>\n<li><code class=\"language-text\">2</code> 表示 <code class=\"language-text\">id</code> 属性在 <code class=\"language-text\">snapshot.meta.node_fields</code> 数组中的偏移量</li>\n</ul>\n<p><code class=\"language-text\">node0</code> 的 <code class=\"language-text\">edge_count</code> 可以表示成 <code class=\"language-text\">nodes[0 + 4]</code>：</p>\n<ul>\n<li>其中 <code class=\"language-text\">4</code> 表示 <code class=\"language-text\">edge_count</code> 属性在 <code class=\"language-text\">snapshot.meta.node_fields</code> 数组中的偏移量</li>\n<li>其他部分同上</li>\n</ul>\n<p>所以 <code class=\"language-text\">edges</code> 数组中，从 <code class=\"language-text\">0</code> 开始的 <code class=\"language-text\">node0.edge_count</code> 个 edge 的 <code class=\"language-text\">From</code> 都是 <code class=\"language-text\">node0.id</code></p>\n<p>因为 <code class=\"language-text\">node[n].edge_count</code> 是变量，所以我们无法快速根据索引定位到某个 edge 的 From，我们必须从索引 <code class=\"language-text\">0</code> 开始，然后步进 <code class=\"language-text\">node[n].edge_count</code> 次（<code class=\"language-text\">n</code> 从 <code class=\"language-text\">0</code> 开始），步进次数内的 edge 的 From 都为 <code class=\"language-text\">node[n].id</code>，步进结束后对 <code class=\"language-text\">n = n + 1</code> ，进而在下一次迭代中关联下一个 node 的 edges</p>\n<h2>heapquery</h2>\n<p>我们开头说了解文件内容可以做一些有趣的事情，接下来我们将演示一个小程序 <a href=\"https://github.com/hsiaosiyuan0/heapquery-js\">heapquery</a>（<a href=\"https://github.com/hsiaosiyuan0/heapquery\">Rust 劝入版</a>），它可以将 <code class=\"language-text\">.heapsnapshot</code> 文件的内容导入到 sqlite 中，然后我们就可以通过 SQL 来查询自己感兴趣的内容了（虽然远没有 <a href=\"https://github.com/osquery/osquery\">osquery</a> 高级，但是直接通过 SQL 来查询堆上的内容，想想都会很有趣吧）</p>\n<p>除此以外，它还可以：</p>\n<ul>\n<li>验证上文对 heapsnapshot 文件格式的分析</li>\n<li>对上文的文字描述提供一个可运行的代码的补充解释</li>\n</ul>\n<p>因为 heapquery 的程序内容非常简单（仅仅是解析格式并导入而已），所以就不赘述了。只简单看一下涉及的表结构，因为仅仅是演示用，到最后其实只有两张表：</p>\n<p><strong>Node 表</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">IF</span> <span class=\"token operator\">NOT</span> <span class=\"token keyword\">EXISTS</span> node <span class=\"token punctuation\">(</span>\n  id <span class=\"token keyword\">INTEGER</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\">/* 对象 id  */</span>\n  name <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>         <span class=\"token comment\">/* 对象所属类型名称 */</span>\n  <span class=\"token keyword\">type</span> <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>         <span class=\"token comment\">/* 对象所属类型枚举，取自 `snapshot.meta.node_types` */</span>\n  self_size <span class=\"token keyword\">INTEGER</span><span class=\"token punctuation\">,</span>        <span class=\"token comment\">/* 对象自身大小 */</span>\n  edge_count <span class=\"token keyword\">INTEGER</span><span class=\"token punctuation\">,</span>       <span class=\"token comment\">/* 对象持有的子对象数量 */</span>\n  trace_node_id <span class=\"token keyword\">INTEGER</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>Edge 表</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">IF</span> <span class=\"token operator\">NOT</span> <span class=\"token keyword\">EXISTS</span> edge <span class=\"token punctuation\">(</span>\n  from_node <span class=\"token keyword\">INTEGER</span><span class=\"token punctuation\">,</span>              <span class=\"token comment\">/* 父对象 id */</span>\n  to_node <span class=\"token keyword\">INTEGER</span><span class=\"token punctuation\">,</span>                <span class=\"token comment\">/* 子对象 id */</span>\n  <span class=\"token keyword\">type</span> <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>               <span class=\"token comment\">/* 关系类型，取自 `snapshot.meta.edge_types` */</span>\n  name_or_index <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span>       <span class=\"token comment\">/* 关系名称，属性名称或者索引 */</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>小演练</h3>\n<p>在本文开头的位置，我们定义了一个 <code class=\"language-text\">HugeObj</code> 类，在实例化该类的时候，会创建一个大小为 50M 的 <code class=\"language-text\">Buffer</code> 对象，并关联到其属性 <code class=\"language-text\">hugeData</code> 上</p>\n<p>接下来我们将进行一个小演练，假设我们事先并不知道 <code class=\"language-text\">HugeObj</code>，我们如何通过可能的内存异常现象反推定位到它</p>\n<p>首先我们需要将 <code class=\"language-text\">.heapsnapshot</code> 导入到 sqlite 中：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">npx heapquery path_to_your_heapdump.heapsnapshot</code></pre></div>\n<p>命令运行完成后，会在当前目录下生成 <code class=\"language-text\">path_to_your_heapdump.db</code> 文件，我们可以选择自己喜欢的 sqlite browser 打开它，比如这里使用的 <a href=\"https://sqlitebrowser.org/\">DB Browser for SQLite</a></p>\n<p>然后我们执行一条 SQL 语句，将 node 按 <code class=\"language-text\">self_size</code> 倒序排列后输出：</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> node <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">By</span> self_size <span class=\"token keyword\">DESC</span></code></pre></div>\n<p>我们会得到类似下面的结果：</p>\n<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7821543808/d63b/015b/ef74/3146cf019e1ed0b59095bbc5a96a2660.png\"></p>\n<p>我们接着从大小可疑的对象入手，当然这里就是先看截图中 <code class=\"language-text\">id</code> 为 <code class=\"language-text\">51389</code> 的这条数据了</p>\n<p>接下来我们再执行一条 SQL 语句，看看是哪个对象持有了对象 <code class=\"language-text\">51389</code></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>  from_node<span class=\"token punctuation\">,</span> B<span class=\"token punctuation\">.</span>name <span class=\"token keyword\">AS</span> from_node_name \n  <span class=\"token keyword\">FROM</span> edge <span class=\"token keyword\">AS</span> A  \n  <span class=\"token keyword\">JOIN</span>  node <span class=\"token keyword\">AS</span> B <span class=\"token keyword\">ON</span> A<span class=\"token punctuation\">.</span>from_node <span class=\"token operator\">=</span> B<span class=\"token punctuation\">.</span>id \n  <span class=\"token keyword\">WHERE</span> A<span class=\"token punctuation\">.</span>to_node <span class=\"token operator\">=</span> <span class=\"token number\">51389</span></code></pre></div>\n<p>我们会得到类似下面的输出：</p>\n<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7821638826/cab4/7b69/79a7/0e314fd9da82c3baaba0cb244045cb7d.png\"></p>\n<p>上面的输出中，我们知道持有 <code class=\"language-text\">51389</code> 的对象是 <code class=\"language-text\">51387</code>，并且该对象的类型是 <code class=\"language-text\">ArrayBuffer</code></p>\n<p>因为 <code class=\"language-text\">ArrayBuffer</code> 是环境内置的类，我们并不能看出什么问题，因此需要利用上面的 SQL，继续查看 <code class=\"language-text\">51387</code> 是被哪个对象持有的：</p>\n<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7821698116/9593/f678/38e1/040be5ca537c340b85d595a2add4bc07.png\"></p>\n<p>和上面的输出类似，这次的 <code class=\"language-text\">Buffer</code> 依然是内置对象，所以我们继续重复上面的步骤：</p>\n<p><img src=\"https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7821713282/c794/782d/993f/2dfe3d049aeb53e64bea45029d1b1512.png\"></p>\n<p>这次我们得到了一个业务对象 <code class=\"language-text\">HugeObj</code>，我们看看它是在哪里定义的。对象的定义就是它的构造函数，因此我们需要找到它的 <code class=\"language-text\">constructor</code>，为此我们先列出对象的所有属性：</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> edge <span class=\"token keyword\">WHERE</span> from_node <span class=\"token operator\">=</span> <span class=\"token number\">46141</span> <span class=\"token operator\">AND</span> <span class=\"token punctuation\">`</span><span class=\"token keyword\">type</span><span class=\"token punctuation\">`</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"property\"</span></code></pre></div>\n<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7821804474/f2a8/7a1e/0fb6/2e1484cb66cc62333e1686a10bcfe864.png\"></p>\n<p>接着我们在原型中继续查找：</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> edge <span class=\"token keyword\">WHERE</span> from_node <span class=\"token operator\">=</span> <span class=\"token number\">4575</span> <span class=\"token operator\">AND</span> <span class=\"token punctuation\">`</span><span class=\"token keyword\">type</span><span class=\"token punctuation\">`</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"property\"</span></code></pre></div>\n<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7821825537/a9bb/f4ad/513c/18a8a4f9f4f2f0762b6c051f6b3e746c.png\"></p>\n<p>我们找到了 <code class=\"language-text\">constructor</code> 对象 <code class=\"language-text\">4577</code>，接着我们来找到它的 <code class=\"language-text\">shared</code> 内部属性：</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> edge <span class=\"token keyword\">WHERE</span> from_node <span class=\"token operator\">=</span> <span class=\"token number\">4577</span> <span class=\"token operator\">AND</span> name_or_index <span class=\"token operator\">=</span> <span class=\"token string\">\"shared\"</span></code></pre></div>\n<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7821872592/e072/1f71/8b93/b88001c0495153cf83691803dafc56e3.png\"></p>\n<p>我们简单解释一下 <code class=\"language-text\">shared</code> 属性的作用是什么。首先，通常函数包含的信息有：</p>\n<ul>\n<li>定义所在的源文件位置</li>\n<li>原始代码（在具有 JIT 的运行时中用于 Deoptimize）</li>\n<li>一组在业务上可复用的指令（Opcode or JITed）</li>\n<li>PC 寄存器信息，表示当然执行到内部哪一个指令，并在未来恢复时可以继续执行</li>\n<li>BP 寄存器信息，表示当前调用栈帧在栈上的起始地址</li>\n<li>函数对象创建时对应的闭包引用</li>\n</ul>\n<p>其中「定义所在的源文件位置」、「原始代码」、「一组在业务上可复用的指令（Opcode or JITed）」是没有必要制造出多份拷贝的，因此类似这样的内容，在 v8 中就会放到 <code class=\"language-text\">shared</code> 对象中</p>\n<p>接下来我们可以输出 <code class=\"language-text\">shared</code> 对象 <code class=\"language-text\">43271</code> 的属性：</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> edge <span class=\"token keyword\">WHERE</span> from_node <span class=\"token operator\">=</span> <span class=\"token number\">43271</span></code></pre></div>\n<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7822067402/efd4/f1dd/6457/72bd851b9cfbc9084141b6e367521ba8.png\"></p>\n<p>我们继续输出 <code class=\"language-text\">script_or_debug_info</code> 属性持有的对象 <code class=\"language-text\">8463</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> edge <span class=\"token keyword\">WHERE</span> from_node <span class=\"token operator\">=</span> <span class=\"token number\">8463</span></code></pre></div>\n<p><img src=\"https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7822092885/b0e1/733b/abac/a1a71e171f415ae8033901838bffcadf.png\"></p>\n<p>最后我们输出 <code class=\"language-text\">name</code> 属性持有的对象 <code class=\"language-text\">4587</code>：</p>\n<p><img src=\"https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7822116292/0952/c86e/eb63/24c7bbb3b6ce0e48fda52e2c6d55a80c.png\"></p>\n<p>这样我们就找到了对象定义的文件，然后就可以在该文件中继续确定业务代码是否存在泄漏的可能</p>\n<p>或许有人会对上面的步骤感到繁琐，其实不必担心，我们可以结合自己实际的查询需求，将常用的查询功能编写成子程序，这样以后只要给一个输入，就能帮助我们分析出想要的结果了</p>\n<h2>小结</h2>\n<p>本文以分析 <code class=\"language-text\">.heapsnapshot</code> 文件的格式为切入点，结合 node 的源码，解释了 <code class=\"language-text\">.heapsnapshot</code> 文件格式和其生成的方式，并提供了个 heapquery 的小程序，演示了了解其结构可以帮助我们获得不局限于现有工具的信息。最后祝大家上分愉快！</p>\n<blockquote>\n<p>本文发布自 <a href=\"https://github.com/x-orpheus\">网易云音乐大前端团队</a>，文章未经授权禁止任何形式的转载。我们常年招收前端、iOS、Android，如果你准备换工作，又恰好喜欢云音乐，那就加入我们 grp.music-fe(at)corp.netease.com！</p>\n</blockquote>","frontmatter":{"title":"v8 Heapsnapshot 文件解析","date":"2021-03-17","description":"解析 heapsnapshot 文件内容，并做点有趣的事情"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/v8-heapsnapshot/","previous":{"fields":{"slug":"/qiankun-practice/"},"frontmatter":{"title":"基于 qiankun 的微前端应用实践"}},"next":{"fields":{"slug":"/libuv/"},"frontmatter":{"title":"Libuv 之 - 只看这篇是不够的"}}}}}