{"componentChunkName":"component---src-templates-blog-post-js","path":"/uibutton/","webpackCompilationHash":"b0082026f0d2e3ac3c54","result":{"data":{"site":{"siteMetadata":{"title":"云音乐大前端专栏","author":"云音乐大前端团队","siteUrl":"https://musicfe.dev"}},"markdownRemark":{"id":"91908816-3b15-544d-84f9-f28d860678a1","excerpt":"题图 本文作者：谭歆 0x0 控件状态 作为 iOS 开发者，一提到控件，就不得不提到 ，它做为 iOS 系统最常用的响应用户点击操作的控件，为我们提供了相当丰富的功能以及可定制性。而我们的日常工作的 80% ~ 90% 做是在与 UI…","html":"<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/4362427093/7ea0/f0e9/e27e/9a59b574ac3cb3e0c5121716d2c336b0.jpg\" alt=\"题图\"></p>\n<blockquote>\n<p>本文作者：谭歆</p>\n</blockquote>\n<h2>0x0 控件状态</h2>\n<p>作为 <strong>iOS</strong> 开发者，一提到控件，就不得不提到 <code class=\"language-text\">UIButton</code>，它做为 <strong>iOS</strong> 系统最常用的响应用户点击操作的控件，为我们提供了相当丰富的功能以及可定制性。而我们的日常工作的 80% ~ 90% 做是在与 <strong>UI</strong> 打交道，处理控件在用户的不同操作下的不同状态，最简单的，比如用户没有登录时，按钮置灰不可点击，用户点击时出现一个反色效果反馈到用户等等。对常用状态的定义，系统在很早的时候就给出了：</p>\n<div class=\"gatsby-highlight\" data-language=\"objective-c\"><pre class=\"language-objective-c\"><code class=\"language-objective-c\">typedef NS_OPTIONS(NSUInteger, UIControlState) {\n    UIControlStateNormal       = 0,\n    UIControlStateHighlighted  = 1 &lt;&lt; 0,                  // used when UIControl isHighlighted is set\n    UIControlStateDisabled     = 1 &lt;&lt; 1,\n    UIControlStateSelected     = 1 &lt;&lt; 2,                  // flag usable by app (see below)\n    UIControlStateFocused API_AVAILABLE(ios(9.0)) = 1 &lt;&lt; 3, // Applicable only when the screen supports focus\n    UIControlStateApplication  = 0x00FF0000,              // additional flags available for application use\n    UIControlStateReserved     = 0xFF000000               // flags reserved for internal framework use\n};</code></pre></div>\n<p>我们一般预先设置好 <code class=\"language-text\">UIButton</code> 在不同状态下的样式，然后直接改对应状态的 <code class=\"language-text\">bool</code> 值即可，使用上比较方便。</p>\n<div class=\"gatsby-highlight\" data-language=\"objective-c\"><pre class=\"language-objective-c\"><code class=\"language-objective-c\">UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];\n// 正常状态\n[button setTitleColor:[UIColor blueColor] forState:UIControlStateNormal];\n// 点击高亮\n[button setTitleColor:[UIColor whiteColor] forState:UIControlStateHighlighted];\n[button setBackgroundImage:[UIImage imageNamed:@&quot;btn_highlighted&quot;] forState:UIControlStateHighlighted];\n// 不可用\n[button setTitleColor:[UIColor grayColor] forState:UIControlStateDisabled];\n\n// 用户登录状态变化时，修改属性值\nif (/* 用户未登录 */) {\n  button.enabled = NO;\n} else {\n  button.enabled = YES;\n}</code></pre></div>\n<p>那么 <code class=\"language-text\">UIButton</code> 只有四种状态可用吗？真实开发中，控件的状态可能很多，四种是一定不够用的。</p>\n<h2>0x1 状态组合</h2>\n<p>首先我们注意到，<code class=\"language-text\">UIControlState</code> 的定义是一个 <strong>NS_OPTIONS</strong>，而不是 <strong>NS_ENUM</strong>，三个有效的 <strong>bit</strong> 两两组合应该有 8 种状态。正好我们可以写个 <strong>Demo</strong> 测试一下：</p>\n<div class=\"gatsby-highlight\" data-language=\"objective-c\"><pre class=\"language-objective-c\"><code class=\"language-objective-c\">UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom];\n\n[btn setTitle:@&quot;Normal&quot; forState:UIControlStateNormal];\n[btn setTitle:@&quot;Selected&quot; forState:UIControlStateSelected];\n[btn setTitle:@&quot;Highlighted&quot; forState:UIControlStateHighlighted];\n[btn setTitle:@&quot;Highlighted &amp; Disabled&quot; forState:UIControlStateHighlighted | UIControlStateDisabled];\n[btn setTitle:@&quot;Disabled&quot; forState:UIControlStateDisabled];\n[btn setTitle:@&quot;Selected &amp; Disabled&quot; forState:UIControlStateSelected | UIControlStateDisabled];\n[btn setTitle:@&quot;Selected &amp; Highlighted &amp; Disabled&quot; forState:UIControlStateSelected | UIControlStateHighlighted | UIControlStateDisabled];\n[btn setTitle:@&quot;Selected &amp; Highlighted&quot; forState:UIControlStateSelected | UIControlStateHighlighted];</code></pre></div>\n<p>实践证明，</p>\n<ul>\n<li><code class=\"language-text\">UIControlStateHighlighted</code> 跟 <code class=\"language-text\">UIControlStateHighlighted | UIControlStateDisabled</code></li>\n<li><code class=\"language-text\">UIControlStateSelected | UIControlStateHighlighted</code> 跟 <code class=\"language-text\">UIControlStateSelected | UIControlStateHighlighted | UIControlStateDisabled</code></li>\n</ul>\n<p>效果是一样的，相互覆盖掉。</p>\n<p><img src=\"https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/4362443652/c74f/4a2b/c1a5/89e7e5eaca4f867d57f3d6577783f4b3.png\" alt=\"ControlState\"></p>\n<p>其实也好理解，因为 <code class=\"language-text\">UIControlStateDisabled</code> 与 <code class=\"language-text\">UIControlStateHighlighted</code> 本来语义上就不应该共存，所以剩下六种可用的状态组合。另外，在实践中发现，当某个状态没有设置样式时，它会以 <code class=\"language-text\">Normal</code> 状态的样式兜底，因此在日常开发中，我们最好将所有用到的状态都设置上对应的样式。</p>\n<h2>0x2 自定义状态</h2>\n<p>有了以上组合后，我们基本上可以覆盖 90% 的日常开发，但是如果需要用到更多状态呢？</p>\n<p>我们在开发 <a href=\"https://apps.apple.com/cn/app/id1492692771\">音街</a> 的个人主页时就遇到了状态不够用的问题，对一个关注按钮，它有以下几种不同的状态（如下图）：</p>\n<ol>\n<li>当前登录用户没有关注该用户</li>\n<li>当前登录用户正在关注该用户</li>\n<li>当前登录用户已经关注该用户</li>\n<li>当前登录用户与该用户互相关注</li>\n</ol>\n<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/4158035740/b0d7/f189/a495/99e9f2c56e04117d234cf544e06105a5.png\" alt=\"关注状态\"></p>\n<p>这样一来用户可以操作的状态就有三种了，而且每种可操作的状态都有相应的高亮样式，于是我们无法仅仅用 <code class=\"language-text\">selected</code> 状态来表示是否已经关注。对于这种需求，一个比较容易想到的办法是在不同数据下，修改同一种状态下的样式：</p>\n<div class=\"gatsby-highlight\" data-language=\"objective-c\"><pre class=\"language-objective-c\"><code class=\"language-objective-c\">[button setTitle:@&quot;关注&quot; forState:UIControlStateNormal];\n[button setTitle:@&quot;已关注&quot; forState:UIControlStateSelected];\n\n// 关注状态变化时\nbutton.selected = YES;\nif (/* 对方也关注了我 */) {\n    [button setTitle:@&quot;互相关注&quot; forState:UIControlStateSelected];\n}</code></pre></div>\n<p>需求是实现了，但控件的使用上不再简单，我们不能在初始化时设置完所有的状态，然后以数据驱动状态，状态驱动样式了，而要增加其他逻辑，并且这种增加很容易产生 <strong>Bug</strong>。</p>\n<p>有没有更好的办法来自定义状态，以实现==样式只设置一次==？</p>\n<p>回头看一下 <code class=\"language-text\">UIControlState</code> 的定义，有一个 <code class=\"language-text\">UIControlStateApplication</code> 好像从来没有用过，是不是可以用来自定义呢？</p>\n<p>我们重用 <code class=\"language-text\">selected</code> 状态作为我们的已关注 <code class=\"language-text\">followed</code> 状态，同时新增 <code class=\"language-text\">loading</code> 关注中状态，和 <code class=\"language-text\">mutual</code> 互相关注状态。</p>\n<div class=\"gatsby-highlight\" data-language=\"objective-c\"><pre class=\"language-objective-c\"><code class=\"language-objective-c\">enum {\n    NKControlStateFollowed  = UIControlStateSelected,\n    NKControlStateMutual    = 1 &lt;&lt; 16 | UIControlStateSelected,\n    NKControlStateLoading   = 1 &lt;&lt; 17 | UIControlStateDisabled,\n};\n\n\n@interface NKLoadingButton : UIButton\n@property (nonatomic, getter=isLoading) BOOL loading;\n@property (nonatomic) UIActivityIndicatorView *spinnerView;\n@end\n\n\n@interface NKFollowButton : NKLoadingButton\n@property (nonatomic, getter=isMutual) BOOL mutual;\n@end</code></pre></div>\n<p>这里的定义需要作以下说明：</p>\n<p>首先，为什么做移位 16 的操作？因为 <code class=\"language-text\">UIControlStateApplication</code> 的值是 <strong>0x00FF0000</strong>，移位 16 （16 到 23 均为合法值）正好让状态位落在它的区间内。</p>\n<p>其次，<code class=\"language-text\">loading</code> 时用户应该是不能点击操作的，所以它要  <strong>或</strong> 上 <code class=\"language-text\">disabled</code> 状态，<code class=\"language-text\">mutual</code> 时一定是已经 <code class=\"language-text\">followed</code> 的了（即 <code class=\"language-text\">selected</code>），所以它要 <strong>或</strong> 上 <code class=\"language-text\">selected</code>。</p>\n<p>最后，<code class=\"language-text\">loading</code> 状态应该其他地方也能复用，因此在继承关系上单独又拆了一层 <code class=\"language-text\">NKLoadingButton</code>。</p>\n<p><code class=\"language-text\">NKLoadingButton</code> 的实现比较简单，需要注意的是，我们要重写 <code class=\"language-text\">-setEnabled:</code> 方法让它在 <code class=\"language-text\">loading</code> 时同时处于不可点击状态。</p>\n<div class=\"gatsby-highlight\" data-language=\"objective-c\"><pre class=\"language-objective-c\"><code class=\"language-objective-c\">@implementation NKLoadingButton\n\n - (UIControlState)state\n{\n    UIControlState state = [super state];\n    \n    if (self.isLoading) {\n        state |= NKControlStateLoading;\n    }\n    \n    return state;\n}\n\n- (void)setEnabled:(BOOL)enabled\n{\n    super.enabled = !_loading &amp;&amp; enabled;\n}\n\n- (void)setLoading:(BOOL)loading\n{\n    if (_loading != loading) {\n        _loading = loading;\n        \n        super.enabled = !loading;\n        \n        if (loading) {\n            [self.spinnerView startAnimating];\n        } else {\n            [self.spinnerView stopAnimating];\n        }\n        \n        [self setNeedsLayout];\n        [self invalidateIntrinsicContentSize];\n    }\n}\n\n@end</code></pre></div>\n<p><code class=\"language-text\">NKFollowButton</code> 的实现如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"objective-c\"><pre class=\"language-objective-c\"><code class=\"language-objective-c\">@implementation NKFollowButton\n\n- (instancetype)initWithFrame:(CGRect)frame\n{\n    self = [super initWithFrame:frame];\n    if (self) {        \n        [self setTitle:@&quot;关注&quot; forState:UIControlStateNormal];\n        [self setTitle:@&quot;已关注&quot; forState:UIControlStateSelected];\n        [self setTitle:@&quot;已关注&quot; forState:UIControlStateSelected | UIControlStateHighlighted];\n        [self setTitle:@&quot;互相关注&quot; forState:NKControlStateMutual];\n        [self setTitle:@&quot;互相关注&quot; forState:NKControlStateMutual | UIControlStateHighlighted];\n\n        [self setTitle:@&quot;&quot; forState:NKControlStateLoading];\n        [self setTitle:@&quot;&quot; forState:NKControlStateLoading | UIControlStateSelected];\n\n        [self setTitle:@&quot;&quot; forState:NKControlStateMutual | NKControlStateLoading];\n        \n        // 以下省略颜色相关设置\n    }\n    return self;\n}\n\n- (UIControlState)state\n{\n    UIControlState state = [super state];\n    \n    if (self.isMutual) {\n        state |= NKControlStateMutual;\n    }\n    \n    return state;\n}\n\n- (void)setSelected:(BOOL)selected\n{\n    super.selected = selected;\n    if (!selected) {\n        self.mutual = NO;\n    }\n}\n\n- (void)setMutual:(BOOL)mutual\n{\n    if (_mutual != mutual) {\n        _mutual = mutual;\n        \n        if (mutual) {\n            self.selected = YES;\n        }\n        \n        [self setNeedsLayout];\n        [self invalidateIntrinsicContentSize];\n    }\n}\n\n@end</code></pre></div>\n<p>我们需要重写 <code class=\"language-text\">-state</code> 方法让外界拿到完整、正确的值，重写 <code class=\"language-text\">-setSelected:</code> 方法和 <code class=\"language-text\">-setMutual:</code> 方法，让它们在某些条件下互斥，某些条件下统一。</p>\n<p>如此，我们实现了只在 <code class=\"language-text\">-init</code> 中设置一次样式，后续仅仅依据服务端返回的数据修改 <code class=\"language-text\">.selected</code> <code class=\"language-text\">.loading</code> <code class=\"language-text\">.mutual</code> 的值即可！</p>\n<h2>0x3 总结</h2>\n<p>本文从单一状态，到组合状态，到自定义状态层层深入了介绍了 <code class=\"language-text\">UIButton</code> 的状态在日常开发中的应用，只用状态来驱动 <strong>UI</strong> 一直是程序员开发中的美好设想，本文算是从一个基本控件上给出了实现参考。另外，我们在查看一些系统提供的 <strong>API</strong> 时，一定要多思考苹果这么设计的意图是什么？他们希望我们怎么使用，以及如何正确使用？</p>\n<blockquote>\n<p>本文发布自 <a href=\"https://github.com/x-orpheus\">网易云音乐大前端团队</a>，文章未经授权禁止任何形式的转载。我们常年招收前端、iOS、Android，如果你准备换工作，又恰好喜欢云音乐，那就加入我们 grp.music-fe(at)corp.netease.com！</p>\n</blockquote>","frontmatter":{"title":"UIButton 状态新解","date":"2020-10-14","description":"UIButton 做为 iOS 开发中最常用的控件，它的状态只有 normal、highlighted、selected、disabled 吗？"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/uibutton/","previous":{"fields":{"slug":"/webide/"},"frontmatter":{"title":"搭建一个属于自己的在线 IDE"}},"next":{"fields":{"slug":"/eventloop/"},"frontmatter":{"title":"聊聊 JavaScript 的并发、异步和事件循环"}}}}}