{"componentChunkName":"component---src-templates-blog-post-js","path":"/web-audio-visualization/","webpackCompilationHash":"932f935fa06f7b7be749","result":{"data":{"site":{"siteMetadata":{"title":"云音乐大前端专栏","author":"云音乐大前端团队"}},"markdownRemark":{"id":"29ce872c-3a9d-5528-b74e-52eaf7aa974e","excerpt":"Web Audio在音频可视化中的应用 本文有两个关键词：和。前者是实践，后者是其背后的技术支持。 Web Audio 是很大的知识点，本文会将重点放在如何获取音频数据这块，对于其 API 的更多内容，可以查看 MDN。 另外，要将音频数据转换成可视化图形，除了了解 Web Audio 之外，还需要对 Canvas…","html":"<p><img src=\"https://p1.music.126.net/hFQuISneu4x9T8aesSpcjw==/109951164381875344.jpg\" alt=\"Web Audio在音频可视化中的应用\"></p>\n<p>本文有两个关键词：<code class=\"language-text\">音频可视化</code>和<code class=\"language-text\">Web Audio</code>。前者是实践，后者是其背后的技术支持。 Web Audio 是很大的知识点，本文会将重点放在<strong>如何获取音频数据</strong>这块，对于其 API 的更多内容，可以查看 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API\">MDN</a>。</p>\n<p>另外，要将音频数据转换成可视化图形，除了了解 Web Audio 之外，还需要对 Canvas （特指2D，下同），甚至 WebGL （可选）有一定了解。如果读者对它们没有任何学习基础，可以先从以下资源入手：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial\">Canvas Tutorial</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL\">WebGL Tutorial</a></li>\n</ul>\n<h1>什么是音频可视化</h1>\n<blockquote>\n<p>通过获取频率、波形和其他来自声源的数据，将其转换成图形或图像在屏幕上显示出来，再进行交互处理。</p>\n</blockquote>\n<p>云音乐有不少跟音频动效相关的案例，但其中有些过于复杂，又或者太偏业务。因此这里就现找了两个相对简单，但有代表性的例子。</p>\n<p>第一个是用 Canvas 实现的音频柱形图。</p>\n<p><img src=\"https://p1.music.126.net/xqmTxWt-lNq1H91i3blk9g==/109951164382012375.jpg\" alt=\"普通版\"></p>\n<p><a href=\"https://vodkgeyttp9c.vod.126.net/vodkgeyttp8/LGSYYgBQ_2704599402_hd.mp4?wsSecret=609cfbbbc72fd64ff8a64852b0e42b8d&#x26;wsTime=1884569383&#x26;coverId=CrxtkYdfva7wcrk9OHGjyg==/109951164382025064&#x26;infoId=110004\">↑点击播放↑</a></p>\n<p>第二个是用 WebGL 实现的粒子效果。</p>\n<p><img src=\"https://p1.music.126.net/hZ3C5AgUq3gv2D1URO5S7A==/109951164382011074.jpg\" alt=\"升级版\"></p>\n<p><a href=\"https://vodkgeyttp9c.vod.126.net/vodkgeyttp8/FInfm6LV_2704575429_shd.mp4?wsSecret=c57742624892a0834961f26eeea710f6&#x26;wsTime=1884568538&#x26;coverId=KOH_mHaWwZ5MDMqEszaZKw==/109951164381996440&#x26;infoId=106006\">↑点击播放↑</a></p>\n<p>在具体实践中，除了这些基本图形（矩形、圆形等）的变换，还可以把音频和自然运动、3D 图形结合到一起。</p>\n<p><img src=\"https://p1.music.126.net/Yh7JBTtBpi-EVwDdx8FpFg==/109951164355413285.jpg?imageView=1&#x26;thumbnail=750x0\" alt=\"其他效果\"></p>\n<p><a href=\"https://www.pinterest.com/mastercassawon/audio-visualizer/\">点击查看：pinterest上的一些视觉效果</a></p>\n<h1>什么是 Web Audio</h1>\n<blockquote>\n<p>Web Audio 是 Web 端处理和分析音频的一套 API 。它可以设置不同的音频来源（包括<code class=\"language-text\">&lt;audio&gt;</code>节点、 ArrayBuffer 、用户设备等），对音频添加音效，生成可视化图形等。</p>\n</blockquote>\n<p>接下来重点介绍 Web Audio 在可视化中扮演的角色，见下图。</p>\n<p><img src=\"https://p1.music.126.net/N8JqnGqitVKU_xt2RPK-oA==/109951164355456571.png?imageView=1&#x26;thumbnail=750x0\" alt=\"Web Audio工作流\"></p>\n<p>简单来说，就是<strong>取数据</strong> + <strong>映射数据</strong>两个过程。我们先把“取数据”这个问题解决，可以按以下5步操作。</p>\n<h2>1. 创建 AudioContext</h2>\n<p>在音频的任何操作之前，都必须先创建 AudioContext 。它的作用是关联音频输入，对音频进行解码、控制音频的播放暂停等基础操作。</p>\n<p>创建方式如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> AudioContext <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span>AudioContext <span class=\"token operator\">||</span> window<span class=\"token punctuation\">.</span>webkitAudioContext<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> ctx <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AudioContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>2. 创建 AnalyserNode</h2>\n<p>AnalyserNode 用于获取音频的频率数据（ FrequencyData ）和时域数据（ TimeDomainData ）。从而实现音频的可视化。</p>\n<p>它只会对音频进行读取，而不会对音频进行任何改变。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> analyser <span class=\"token operator\">=</span> ctx<span class=\"token punctuation\">.</span><span class=\"token function\">createAnalyser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nanalyser<span class=\"token punctuation\">.</span>fftSize <span class=\"token operator\">=</span> <span class=\"token number\">512</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>关于 fftSize ，在 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/fftSize\">MDN</a> 上的介绍可能很难理解，说是快速傅里叶变换的一个参数。</p>\n<p>可以从以下角度理解：</p>\n<p><strong>1. 它的取值是什么？</strong></p>\n<p>fftSize 的要求是 2 的幂次方，比如 256 、 512 等。数字越大，得到的结果越精细。</p>\n<p>对于移动端网页来说，本身音频的比特率大多是 128Kbps ，没有必要用太大的频率数组去存储本身就不够精细的源数据。另外，手机屏幕的尺寸比桌面端小，因此最终展示图形也不需要每个频率都采到。只需要体现节奏即可，因此 512 是较为合理的值。</p>\n<p><strong>2. 它的作用是什么？</strong></p>\n<p>fftSize 决定了 frequencyData 的长度，具体为 fftSize 的一半。</p>\n<p>至于为什么是 1 / 2，感兴趣的可以看下这篇文章：<a href=\"https://dsp.stackexchange.com/questions/4825/why-is-the-fft-mirrored\">Why is the FFT “mirrored”?</a> </p>\n<h2>3. 设置 SourceNode</h2>\n<p>现在，我们需要将音频节点，关联到 AudioContext 上，作为整个音频分析过程的输入。</p>\n<p>在 Web Audio 中，有三种类型的音频源：</p>\n<ul>\n<li><strong>MediaElementAudioSourceNode</strong> 允许将<code class=\"language-text\">&lt;audio&gt;</code>节点直接作为输入，可做到流式播放。</li>\n<li><strong>AudioBufferSourceNode</strong> 通过 xhr 预先将音频文件加载下来，再用 AudioContext 进行解码。</li>\n<li><strong>MediaStreamAudioSourceNode</strong> 可以将用户的麦克风作为输入。即通过<code class=\"language-text\">navigator.getUserMedia</code>获取用户的音频或视频流后，生成音频源。</li>\n</ul>\n<p>这 3 种音频源中，除了 MediaStreamAudioSourceNode 有它不可替代的使用场景（比如语音或视频直播）之外。 MediaElementAudioSourceNode 和 AudioBufferSourceNode 相对更容易混用，因此这里着重介绍一下。</p>\n<h3>MediaElementAudioSourceNode</h3>\n<p>MediaElementAudioSourceNode 将<code class=\"language-text\">&lt;audio&gt;</code>标签作为音频源。它的 API 调用非常简单。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 获取&lt;audio>节点</span>\n<span class=\"token keyword\">const</span> audio <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'audio'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 通过&lt;audio>节点创建音频源</span>\n<span class=\"token keyword\">const</span> source <span class=\"token operator\">=</span> ctx<span class=\"token punctuation\">.</span><span class=\"token function\">createMediaElementSource</span><span class=\"token punctuation\">(</span>audio<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 将音频源关联到分析器</span>\nsource<span class=\"token punctuation\">.</span><span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>analyser<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 将分析器关联到输出设备（耳机、扬声器）</span>\nanalyser<span class=\"token punctuation\">.</span><span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">.</span>destination<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>AudioBufferSourceNode</h3>\n<p>有一种情况是，在安卓端，测试了在<code class=\"language-text\">Chrome/69</code>（不含）以下的版本，用 MediaElementAudioSourceNode 时，获取到的 frequencyData 是全为 0 的数组。</p>\n<p>因此，想要兼容这类机器，就需要换一种预加载的方式，即使用 AudioBufferSourceNode ，加载方式如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 创建一个xhr</span>\n<span class=\"token keyword\">var</span> xhr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">XMLHttpRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nxhr<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">'GET'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'/path/to/audio.mp3'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 设置响应类型为 arraybuffer</span>\nxhr<span class=\"token punctuation\">.</span>responseType <span class=\"token operator\">=</span> <span class=\"token string\">'arraybuffer'</span><span class=\"token punctuation\">;</span>\n\nxhr<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onload</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> source <span class=\"token operator\">=</span> ctx<span class=\"token punctuation\">.</span><span class=\"token function\">createBufferSource</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 对响应内容进行解码</span>\n    ctx<span class=\"token punctuation\">.</span><span class=\"token function\">decodeAudioData</span><span class=\"token punctuation\">(</span>xhr<span class=\"token punctuation\">.</span>response<span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">buffer</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token comment\">// 将解码后得到的值赋给buffer</span>\n        source<span class=\"token punctuation\">.</span>buffer <span class=\"token operator\">=</span> buffer<span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 完成。将source绑定到ctx。也可以连接AnalyserNode</span>\n        source<span class=\"token punctuation\">.</span><span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">.</span>destination<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nxhr<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>如果将 AnalyserNode 类比中间件，会不会好理解一些？</p>\n<p>可以对比一下常规的<code class=\"language-text\">&lt;audio&gt;</code>播放，和 Web Audio 中的播放流程：</p>\n<p><img src=\"https://p1.music.126.net/emnTIcCaE1TR6XOjAAF3ew==/109951164356365246.png?imageView=1&#x26;thumbnail=750x0\" alt=\"两种播放逻辑对比\"></p>\n<h2>4. 播放音频</h2>\n<p>对于<code class=\"language-text\">&lt;audio&gt;</code>节点，即使用 MediaElementAudioSourceNode 的话，播放相对比较熟悉：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">audio<span class=\"token punctuation\">.</span><span class=\"token function\">play</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>但如果是 AudioBufferSourceNode ，它不存在 play 方法，而是：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 创建AudioBufferSourceNode</span>\n<span class=\"token keyword\">const</span> source <span class=\"token operator\">=</span> ctx<span class=\"token punctuation\">.</span><span class=\"token function\">createBufferSource</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// buffer是通过xhr获取的音频文件</span>\nsource<span class=\"token punctuation\">.</span>buffer <span class=\"token operator\">=</span> buffer<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 调用start方法进行播放</span>\nsource<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>5. 获取 frequencyData</h2>\n<p>到此，我们已经将音频输入关联到一个 AnalyserNode ，并且开始播放音频。对于 Web Audio 这部分来说，它只剩最后一个任务：获取频率数据。</p>\n<p>关于频率， Web Audio 提供了两个相关的 API，分别是：</p>\n<ol>\n<li><code class=\"language-text\">analyser.getByteFrequencyData</code></li>\n<li><code class=\"language-text\">analyser.getFloatFrequencyData</code></li>\n</ol>\n<p>两者都是返回 TypedArray ，唯一的区别是精度不同。</p>\n<p>getByteFrequencyData 返回的是 0 - 255 的 Uint8Array 。而 getFloatFrequencyData 返回的是 0 - 22050 的 Float32Array 。</p>\n<p>相比较而言，如果项目中对性能的要求高于精度，那建议使用 getByteFrequencyData 。下图展示了一个具体例子：</p>\n<p><img src=\"https://p1.music.126.net/dDz7hEfigBpigk0rMGsdgw==/109951164356384964.jpg?imageView=1&#x26;thumbnail=750x0\" alt=\"getByteFrequencyData\"></p>\n<p>关于数组的长度（ 256 ），在上文已经解释过，它是 fftSize 的一半。</p>\n<p>现在，我们来看下如何获取频率数组：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> bufferLength <span class=\"token operator\">=</span> analyser<span class=\"token punctuation\">.</span>frequencyBinCount<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> dataArray <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Uint8Array</span><span class=\"token punctuation\">(</span>bufferLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nanalyser<span class=\"token punctuation\">.</span><span class=\"token function\">getByteFrequencyData</span><span class=\"token punctuation\">(</span>dataArray<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>需要注意的是， getByteFrequencyData 是对已有的数组元素进行赋值，而不是创建后返回新的数组。</p>\n<p>它的好处是，在代码中只会有一个 dataArray 的引用，不用通过函数调用和参数传递的方式来重新取值。</p>\n<h1>可视化的两种实现方案</h1>\n<p>在了解 Web Audio 之后，已经能用 getByteFrequencyData 取到一个 Uint8Array 的数组，暂时命名为 dataArray 。</p>\n<p>从原理上讲，可视化所依赖的数据可以是音频，也可以是温度变化，甚至可以是随机数。所以，接下来的内容，我们只需要关心如何将 dataArray 映射为图形数据，不用再考虑 Web Audio 的操作。</p>\n<p>（为了简化 Canvas 和 WebGL 的描述，下文提到 Canvas 特指 <code class=\"language-text\">Canvas 2D</code>。）</p>\n<h2>1. Canvas 方案</h2>\n<p><a href=\"https://codepen.io/jchenn/pen/LYPdjWN\">点击查看：第1个示例的源码</a></p>\n<p>Canvas 本身是一个序列帧的播放。它在每一帧中，都要先清空 Canvas ，再重新绘制。</p>\n<p><img src=\"https://p1.music.126.net/JjWaNqHv8fvLuzZ0UzzSZQ==/109951164356477137.png?imageView=1&#x26;thumbnail=750x0\" alt=\"Canvas工作流程\"></p>\n<p>以下是从示例代码中摘取的一段：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">renderFrame</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">requestAnimationFrame</span><span class=\"token punctuation\">(</span>renderFrame<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 更新频率数据</span>\n    analyser<span class=\"token punctuation\">.</span><span class=\"token function\">getByteFrequencyData</span><span class=\"token punctuation\">(</span>dataArray<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// bufferLength表示柱形图中矩形的个数</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> x <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> bufferLength<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 根据频率映射一个矩形高度</span>\n        barHeight <span class=\"token operator\">=</span> dataArray<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 根据每个矩形高度映射一个背景色</span>\n        <span class=\"token keyword\">var</span> r <span class=\"token operator\">=</span> barHeight <span class=\"token operator\">+</span> <span class=\"token number\">25</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">/</span> bufferLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">var</span> g <span class=\"token operator\">=</span> <span class=\"token number\">250</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">/</span> bufferLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token number\">50</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 绘制一个矩形，并填充背景色</span>\n        ctx<span class=\"token punctuation\">.</span>fillStyle <span class=\"token operator\">=</span> <span class=\"token string\">\"rgb(\"</span> <span class=\"token operator\">+</span> r <span class=\"token operator\">+</span> <span class=\"token string\">\",\"</span> <span class=\"token operator\">+</span> g <span class=\"token operator\">+</span> <span class=\"token string\">\",\"</span> <span class=\"token operator\">+</span> b <span class=\"token operator\">+</span> <span class=\"token string\">\")\"</span><span class=\"token punctuation\">;</span>\n        ctx<span class=\"token punctuation\">.</span><span class=\"token function\">fillRect</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> <span class=\"token constant\">HEIGHT</span> <span class=\"token operator\">-</span> barHeight<span class=\"token punctuation\">,</span> barWidth<span class=\"token punctuation\">,</span> barHeight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        x <span class=\"token operator\">+=</span> barWidth <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">renderFrame</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>对于可视化来说，核心逻辑在于：如何把频率数据映射成图形参数。在上例中，只是简单地改变了柱形图中每一个矩形的高度和颜色。</p>\n<p>Canvas 提供了丰富的绘制API，仅从 2D 的角度考虑，它也能实现很多酷炫的效果。类比 DOM 来说，如果只是<code class=\"language-text\">&lt;div&gt;</code>的组合就能做出丰富多彩的页面，那么 Canvas 一样可以。</p>\n<h2>2. WebGL 方案</h2>\n<p><a href=\"https://codepen.io/jchenn/pen/WNezZdN\">点击查看：第2个示例的源码</a></p>\n<p>Canvas 是 CPU 计算，对于 for 循环计算 10000 次，而且每一帧都要重复计算， CPU 是负载不了的。所以我们很少看到用 Canvas 2D 去实现粒子效果。取而代之的，是使用 WebGL ，借助 GPU 的计算能力。</p>\n<p>在 WebGL 中，有一个概念相对比较陌生——着色器。它是运行在 GPU 中负责渲染算法的一类总称。它使用 GLSL（ OpenGL Shading Language ）编写，简单来说是一种类 C 风格的语言。以下是简单的示例：</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">void main()\n{\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}</code></pre></div>\n<p>关于着色器更详细的介绍，可以<a href=\"http://zhangwenli.com/blog/2017/02/24/what-is-a-shader/\">查看这篇文章</a>。</p>\n<p>WebGL 的原生 API 是非常复杂的，因此我们使用<code class=\"language-text\">Three.js</code>作为基础库，它会让业务逻辑的编写变得简单。</p>\n<p>先来看下整个开发流程中做的事情，如下图：</p>\n<p><img src=\"https://p1.music.126.net/joRPzt3PBuqKrJGmBAdA9w==/109951164356746955.png?imageView=1&#x26;thumbnail=750x0\" alt=\"WegGL开发流程\"></p>\n<p>在这个过程中， uniforms 的类型是简单 Object ，我们会将音频数组作为 uniforms 的一个属性，传到着色器中。至于着色器做的事情，可以简单理解为，它将 uniforms 中定义的一系列属性，映射为屏幕上的顶点和颜色。</p>\n<p>顶点着色器和片元着色器的编写往往不需要前端开发参与，对于学过 Unity3D 等技术的游戏同学可能会熟悉一些。读者可以到 <a href=\"https://www.shadertoy.com/\">ShaderToy</a> 上寻找现成的着色器。</p>\n<p><img src=\"https://p1.music.126.net/ZqHJpcvMSRjI06o35y346Q==/109951164356763693.jpg?imageView=1&#x26;thumbnail=750x0\" alt=\"ShaderToy\"></p>\n<p>然后介绍以下3个 Three.js 中的类：</p>\n<p><strong>1. THREE.Geometry</strong></p>\n<p>可以理解为形状。也就是说，最后展示的物体是球体、还是长方体、还是其他不规则的形状，是由这个类决定的。</p>\n<p>因此，你需要给它传入一些顶点的坐标。比如三角形，有3个顶点，则传入3个顶点坐标。</p>\n<p>当然， Three.js 内置了很多常用的形状，比如 BoxGeometry 、 CircleGeometry 等。</p>\n<p><strong>2. THREE.ShaderMaterial</strong></p>\n<p>可以理解为颜色。还是以三角形为例，一个三角形可以是黑色、白色、渐变色等，这些颜色是由 ShaderMaterial 决定的。</p>\n<p>ShaderMaterial 是 Material 的一种，它由顶点着色器和片元着色器进行定义。</p>\n<p><strong>3. THREE.Mesh</strong></p>\n<p>定义好物体的形状和颜色后，需要把它们组合在一起，称作 Mesh （网格）。有了 Mesh 之后，便可以将它添加到画布中。然后就是常规的 requestAnimationFrame 的流程。</p>\n<p>同样的，我们摘取了示例中比较关键的代码，并做了标注。</p>\n<p>i. 创建 Geometry （这是从 THREE.BufferGeometry 继承的类）：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> geometry <span class=\"token operator\">=</span> <span class=\"token function\">ParticleBufferGeometry</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// TODO 一些参数</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>ii. 定义 uniforms ：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> uniforms <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    dataArray<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        value<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n        type<span class=\"token punctuation\">:</span> <span class=\"token string\">'t'</span> <span class=\"token comment\">// 对应THREE.DataTexture</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token comment\">// TODO 其他属性</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>iii. 创建 ShaderMaterial ：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> material <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">THREE<span class=\"token punctuation\">.</span>ShaderMaterial</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    uniforms<span class=\"token punctuation\">:</span> uniforms<span class=\"token punctuation\">,</span>\n    vertexShader<span class=\"token punctuation\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// TODO 传入顶点着色器</span>\n    fragmentShader<span class=\"token punctuation\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// TODO 传入片元着色器</span>\n    <span class=\"token comment\">// TODO 其他参数</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>iv. 创建 Mesh ：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> mesh <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">THREE<span class=\"token punctuation\">.</span>Mesh</span><span class=\"token punctuation\">(</span>geometry<span class=\"token punctuation\">,</span> material<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>v. 创建 Three.js 中一些必须的渲染对象，包括场景和摄像头：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> scene<span class=\"token punctuation\">,</span> camera<span class=\"token punctuation\">,</span> renderer<span class=\"token punctuation\">;</span>\n\nrenderer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">THREE<span class=\"token punctuation\">.</span>WebGLRenderer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    antialias<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    alpha<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\ncamera <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">THREE<span class=\"token punctuation\">.</span>PerspectiveCamera</span><span class=\"token punctuation\">(</span><span class=\"token number\">45</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">.1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1e3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nscene <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">THREE<span class=\"token punctuation\">.</span>Scene</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>vi. 常规的渲染逻辑：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">animate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">requestAnimationFrame</span><span class=\"token punctuation\">(</span>animate<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// TODO 此处可以触发事件，用于更新频率数据</span>\n\n    renderer<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>scene<span class=\"token punctuation\">,</span> camera<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h1>小结</h1>\n<p>本文首先介绍了如何通过 Web Audio 的相关 API 获取音频的频率数据。</p>\n<p>然后介绍了 Canvas 和 WebGL 两种可视化方案，将频率数据映射为图形数据的一些常用方式。</p>\n<p>另外，云音乐客户端上线鲸云动效已经有一段时间，看过本文之后，有没有同学想尝试实现一个自己的音频动效呢？</p>\n<p><img src=\"https://p1.music.126.net/Lbo5RI3d7bJ1xiY1_iPDFA==/109951164358551772.jpg?imageView=1&#x26;thumbnail=750x0\" alt=\"云音乐鲸云动效\"></p>\n<p>最后附上文中提到的两段 codepen 示例：</p>\n<ol>\n<li><a href=\"https://codepen.io/jchenn/pen/LYPdjWN\">https://codepen.io/jchenn/pen/LYPdjWN</a></li>\n<li><a href=\"https://codepen.io/jchenn/pen/WNezZdN\">https://codepen.io/jchenn/pen/WNezZdN</a></li>\n</ol>\n<blockquote>\n<p>本文发布自 <a href=\"https://github.com/x-orpheus\">网易云音乐前端团队</a>，文章未经授权禁止任何形式的转载。我们一直在招人，如果你恰好准备换工作，又恰好喜欢云音乐，那就 <a href=\"mailto:grp.music-fe@corp.netease.com\">加入我们</a>！</p>\n</blockquote>","frontmatter":{"title":"Web Audio在音频可视化中的应用","date":"2019-09-26","description":"本文有两个关键词：`音频可视化`和`Web Audio`。前者是实践，后者是其背后的技术支持。 Web Audio 是很大的知识点，本文会将重点放在**如何获取音频数据**这块。"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/web-audio-visualization/","previous":{"fields":{"slug":"/aws-serverless/"},"frontmatter":{"title":"快速上手亚马逊的 Serverless 服务"}},"next":{"fields":{"slug":"/svrx/"},"frontmatter":{"title":"Server-X：一款可能提升你十倍工作效率的工具"}}}}}