{"componentChunkName":"component---src-templates-blog-post-js","path":"/svrx-mock/","webpackCompilationHash":"95f1de1856b8b6766301","result":{"data":{"site":{"siteMetadata":{"title":"云音乐大前端专栏","author":"云音乐大前端团队","siteUrl":"https://musicfe.dev"}},"markdownRemark":{"id":"a0caaf35-9c66-54b4-8885-81c9423628eb","excerpt":"导言 目前 Web 开发普遍都切换到了前后端分离的开发模式。虽然在工程和职能上已经分离了，但在实际工作中，前后端在开发进度上往往会出现不一致的情况，此时就会极大地影响开发效率。\n接口 mock 在此时就发挥出了巨大价值，它磨平了这个时间差，最终实现高效的前后端分离开发。 具体到接口 mock…","html":"<p><img src=\"https://p1.music.126.net/K6JCLahP2dWrQSHM66xbyg==/109951164497762461.png\"></p>\n<h2>导言</h2>\n<p>目前 Web 开发普遍都切换到了前后端分离的开发模式。虽然在工程和职能上已经分离了，但在实际工作中，前后端在开发进度上往往会出现不一致的情况，此时就会极大地影响开发效率。\n<strong>接口 mock</strong> 在此时就发挥出了巨大价值，它磨平了这个时间差，最终实现高效的前后端分离开发。</p>\n<p>具体到接口 mock 方案就多种多样了，但大体不外乎 「硬编码」 、 「前端拦截」和「后端拦截」这三种。\n本文会尝试简单分析这三种常见方案的优劣，然后引出主要议题：基于 <strong><a href=\"https://docs.svrx.io/zh/\">svrx</a></strong> 的接口 mock 方案。</p>\n<h2>硬编码方案</h2>\n<p>硬编码即在前端代码中直接写入 mock 数据，比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">id</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> username<span class=\"token punctuation\">:</span> <span class=\"token string\">'mock username'</span><span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">:</span> <span class=\"token number\">100</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//接口mock</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">ajax</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/user'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> id <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>提交时移除或注释掉即可：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">id</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// return {username: 'mock username', id: 100}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">ajax</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">/user/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>id<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>后端硬编码的 mock 方式亦是如此，不过它的侵入性保留在了后端逻辑中，前端的业务代码可以保持干净：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">router<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/user/:id'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">async</span> <span class=\"token parameter\">ctx</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  ctx<span class=\"token punctuation\">.</span>body <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> username<span class=\"token punctuation\">:</span> <span class=\"token string\">'mock username'</span><span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">:</span> <span class=\"token number\">100</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// ctx.body = await userService.get(ctx.params.id);</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><em>注：上述范例基于 Koa 框架</em></p>\n<p><strong>硬编码的优点</strong></p>\n<ul>\n<li>简单灵活，不需要任何工具和框架支持，就地使用。</li>\n<li>如果是前端硬编码，支持修改生效，不需要重启 server。</li>\n</ul>\n<p><strong>硬编码缺点</strong></p>\n<ul>\n<li>接口 mock 和业务代码耦合，<strong>挖坑一时爽，填坑火葬场</strong>。</li>\n</ul>\n<p>这种骚操作估计很多人年轻时都干过，提交时忘记删除导致夹带私货上线的车祸现场历历在目。\n无论是否用一些专业的 mock 框架（比如 <a href=\"http://mockjs.com\">mock.js</a> ），这种在业务逻辑中耦合的方式显然是下下策，线上事故通报中可能往往因此就有了你的名字。</p>\n<p>稍严谨的同学可能会配合构建工具(如 webpack )来实现本地 mock 代码和业务代码的隔离，但并未在本质上解决这种耦合关系，随着项目的迭代，项目同样也会变得难以维护。</p>\n<p>更好的做法其实是将 mock 逻辑与业务逻辑完全解耦，并放到<strong>独立的切面中管理</strong>， 这样就可以避免将非业务代码提交到仓库。</p>\n<p>这种切面分为前端拦截和后端拦截两种方式，如下图所示，数据响应直接在对应的切面中被拦截返回：</p>\n<p><img src=\"https://p1.music.126.net/Vvs-10wmVeYl0FVKqKInaw==/109951164481882357.png\"></p>\n<h2>前端拦截</h2>\n<p><strong>前端拦截即在请求真正发送前做的拦截返回</strong>，这种切面通常可以通过 「<strong>Webview 容器定制</strong>」 和 「<strong>浏览器插件</strong>」 两种方式来实现。</p>\n<h3>Webview 容器定制</h3>\n<p>Webview 容器定制一般可以通过「网络拦截」和「脚本注入」两种方式，这也是一般混合应用中前端和 Native 交互的主要方式。</p>\n<p><strong>网络拦截</strong></p>\n<p>网络拦截经常会用在类似离线包的功能场景中，配合 mock 管理工具当然也可以用来接口模拟。 参考 Android，一般会使用下面的方法进行拦截来替换响应</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">WebResourceResponse</span> <span class=\"token function\">shouldInterceptRequest</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> <span class=\"token class-name\">WebView</span> view<span class=\"token punctuation\">,</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> urlstr<span class=\"token punctuation\">)</span></code></pre></div>\n<p><em>此内容不是本文主要议题，不再深入展开</em></p>\n<p><strong>脚本注入</strong></p>\n<p>Android 和 iOS 都有能力向 Webview 直接注入 JS 逻辑，这也是 Hybrid 应用中 Bridge 通信层的实现方式。</p>\n<p>如果在注入脚本中通过魔改 fetch 或 XMLHttpRequest 等原生对象，就可以达到对响应的拦截改写。</p>\n<p><strong>iOS 关键 API 举例</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"objc\"><pre class=\"language-objc\"><code class=\"language-objc\">[self.webView stringByEvaluatingJavaScriptFromString:injectjs];</code></pre></div>\n<p><strong>Android 关键代码片段</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">webView<span class=\"token punctuation\">.</span><span class=\"token function\">loadUrl</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"javascript:\"</span> <span class=\"token operator\">+</span> injectjs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>但无论是网络拦截还是脚本注入，基于 Webview 容器的拦截很少会用在真实场景中，因为定制和使用成本都太高，而且只在本 App 中可以被使用。</p>\n<h3>浏览器插件</h3>\n<p>相较于定制 Webview 容器，浏览器插件显然是一个成本更低的前端容器劫持方案。\n以 <a href=\"https://github.com/code-mancers/interceptor\">code-mancers/interceptor</a> 这个项目为例：</p>\n<p><img src=\"https://p1.music.126.net/bqC3agTPMA-uVJS3_bDsKw==/109951164476414249.png\"></p>\n<p>通过 Interceptor 插件，可以很容易以 GUI 的方式配置我们的 mock 数据，简单直观，且完全不侵入工程代码。</p>\n<h3>前端拦截分析</h3>\n<p>前端拦截有个两个天然优势：</p>\n<ul>\n<li><strong>可提供配置界面</strong>：由于是在浏览器端拦截，可使用 DOM API 提供例如<a href=\"https://github.com/code-mancers/interceptor\"> Interceptor 插件</a>的可配置界面。</li>\n<li><strong>就地生效</strong>：修改后无需重启服务。</li>\n</ul>\n<p>但无论是浏览器插件还是定制 Webview 容器，实际上我们都忽略了一个重要事实：<strong>浏览器环境其实是多种多样的</strong>。\n这导致了前端拦截的一个典型缺陷：<strong>无法跨浏览器使用</strong>，如上例的<a href=\"https://github.com/code-mancers/interceptor\">Intercepror插件</a>就无法在微信浏览器中使用。</p>\n<p>如果是通过服务端拦截的话就可以避免这种情况。</p>\n<h2>服务端拦截方案</h2>\n<p>服务端拦截实现接口 mock，主要通过一个单独的 dev server 层来实现，它一般在访问真实接口前拦截请求并返回模拟数据。</p>\n<h3>裸奔的 dev server</h3>\n<p>方便起见，以 <a href=\"https://koajs.com\">Koa</a> 为例，裸奔一个 dev server：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> proxy <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'koa-proxy'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> Koa <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'koa'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> app <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Koa</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\napp<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">ctx<span class=\"token punctuation\">,</span> next</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">'/api/blog'</span><span class=\"token punctuation\">:</span>\n      ctx<span class=\"token punctuation\">.</span>body <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> type<span class=\"token punctuation\">:</span> <span class=\"token string\">'blog'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">'/api/user'</span><span class=\"token punctuation\">:</span>\n      ctx<span class=\"token punctuation\">.</span>body <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> type<span class=\"token punctuation\">:</span> <span class=\"token string\">'user'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\napp<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span>\n  <span class=\"token function\">proxy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    host<span class=\"token punctuation\">:</span> <span class=\"token string\">'http://api.yoursite.com'</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\napp<span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token number\">8000</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">server start at http://localhost:8000</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>如上例所见, 默认会将接口代理到 <code class=\"language-text\">api.yoursite.com</code>(你的目标 API 或后端基友的服务器)。\nmock 数据的优先级大于真实的代理接口，比如我们访问<code class=\"language-text\">https://localhost:8000/api/user</code>，返回的就是我们的 mock 数据，后续如果需要增加 mock 接口，则需要不断添加 case 分支。</p>\n<p>这种裸奔的方式很不直观，因为它<strong>将 mock 规则和其他 dev server 的配置逻辑杂糅了</strong>，且对于非 Node 选手有较高的学习成本。</p>\n<h3>专业的 dev server</h3>\n<p>由于裸奔 server 的明显痛点，一些聚焦于 dev server 领域的解决方案就开始大行其道，比如开发者耳熟能详的 <a href=\"https://webpack.docschina.org/configuration/dev-server/\">webpack-dev-server</a>。</p>\n<p>它集成了一些通用服务配置，例如端口、host、代理等等，并且设计为被集成在 webpack 的构建流程中以实现构建产物的 serve。\n这样我们就可以将 mock 逻辑比较独立的嵌入其中，以下述 webpack 配置为例：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//...</span>\n  devServer<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    port<span class=\"token punctuation\">:</span> <span class=\"token number\">9000</span><span class=\"token punctuation\">,</span>\n    headers<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token string\">'X-Custom-Foo'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'bar'</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    proxy<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token string\">'/api'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'http://localhost:3000'</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function\">before</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">app</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 配置mock逻辑</span>\n      app<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api/blog'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> res</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        res<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> custom<span class=\"token punctuation\">:</span> <span class=\"token string\">'response'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><em>(专业的 dev server 用预设的配置代替了手工的代码逻辑，显著提高了开发效率)</em></p>\n<p>但无论是裸起还是使用专业的 dev server，本质上还是存在以下问题：</p>\n<ul>\n<li><strong>不支持热重载</strong>: 每次修改 mock 规则，都需要重新启动服务器。</li>\n<li><strong>不直观</strong>: mock 规则和其他 server 配置杂糅，且对于非 Node 选手有较高的学习成本。</li>\n<li><strong>无法提供界面支持</strong>，相较于前端拦截, 它无法提供 GUI 的界面配置能力。</li>\n</ul>\n<h2>使用 svrx 实现高效的接口 mock</h2>\n<p>从以上分析可以得出：前端拦截与后端拦截，都存在一些本质缺陷。\n那是否有一种方式是同时拥有前后端接口 mock 的优势呢？答案就是 <a href=\"https://docs.svrx.io/zh/\"><strong>svrx</strong></a>。</p>\n<blockquote>\n<p><em>广告高能预警，看到这一步了，相信你已经是 svrx 的潜在客户了</em></p>\n</blockquote>\n<h3>svrx 简介</h3>\n<p><a href=\"https://docs.svrx.io/zh/\">svrx</a>(音：Server-X) 是一个微内核架构、插件化的前端开发服务器，内部功能模块主要包含三个部分：</p>\n<ul>\n<li><strong>前端注入模块</strong>： svrx 劫持所有 html 响应注入种子脚本，此脚本会集成管理所注册的前端资源（JS、CSS）。</li>\n<li><strong>后端注入模块</strong>： svrx 内置一个带有优先级的中间件注册模块。</li>\n<li><strong>前后端通信模块</strong>： 实现前端与后端注入的通信方式统一(基于 websocket)，可以以同构的方式完成事件或消息通信。</li>\n</ul>\n<p><img src=\"https://p1.music.126.net/TNL6UMLzvBzg7UMqLgIQKQ==/109951164495974023.png?param=720x0\"></p>\n<p><em>如上图所示，通过清晰的模块划分，插件可以以统一的方式来完成插件注册，灵活使用前端和后端注入功能。</em></p>\n<p>svrx 也抽离了 dev-server 的通用功能，作为内置插件集成(包括 livereload、proxy、https 等等)，其他专有领域的功能(如 markdown、qrcode 等)则以外部插件的方式提供，最大化实现便捷和灵活的平衡。</p>\n<p>其中细分到接口 mock 领域，目前也有一系列开箱即用的配套满足开发者的需求。让我们来试一试吧！</p>\n<p><strong>安装</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">npm install @svrx<span class=\"token operator\">/</span>cli <span class=\"token operator\">-</span>g</code></pre></div>\n<p><em>注: 后续所有插件能力都不需要再显式安装了</em></p>\n<p><strong>使用</strong></p>\n<p>切换到你的工作目录并运行<code class=\"language-text\">svrx</code>，你会发现一个通用的 dev-server 已经运行起来了。</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">svrx</code></pre></div>\n<h3>svrx Routing DSL 实现接口 mock</h3>\n<p>具体到接口 mock 的需求，我们可以直接使用内置的<a href=\"https://docs.svrx.io/zh/guide/route.html\">动态路由功能</a>：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">touch route<span class=\"token punctuation\">.</span>js\nsvrx <span class=\"token operator\">--</span>route route<span class=\"token punctuation\">.</span>js</code></pre></div>\n<p><img src=\"https://p1.music.126.net/rcXow3maqkkqLudiQd5A4Q==/109951164482113080.png\"></p>\n<p>以上就是成功启动的界面, 在<code class=\"language-text\">route.js</code>加入以下代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api/user/:id'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>to<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">:</span> <span class=\"token string\">'svrx'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>浏览器打开<code class=\"language-text\">/api/user/1</code>，可以看到对应的 JSON 响应。所有在<code class=\"language-text\">route.js</code>的改动都是支持 <strong>hot reload</strong> 的，我们无需重启服务器。</p>\n<blockquote>\n<p>更多 <a href=\"https://docs.svrx.io/zh/guide/route.html\">svrx Routing DSL 的使用指南请点击这里</a></p>\n</blockquote>\n<p>如果你使用 svrx 路由来代替上面的其他 dev-server，除了路由写法更直观高效外，还有一个作用就是可以更细粒度地管理路由的优先级，比如 mock 和 proxy 的优先级：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api/user/:id'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>to<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">:</span> <span class=\"token string\">'svrx'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">post</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api/blog(.*)'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>to<span class=\"token punctuation\">.</span><span class=\"token function\">proxy</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http://path.to.api.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/(.*)'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>to<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">'404 PAGE IS NOT FOUND'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><em>注:路由规则越前置，优先级越高</em></p>\n<h3>使用 mock 插件来快速模拟接口</h3>\n<p>直接裸用 svrx 路由能解决 mock 的功能性问题，但无法解决 mock 的效率问题。</p>\n<p>基于此，svrx 官方提供了<a href=\"https://github.com/svrxjs/svrx-plugin-mock\">svrx-plugin-mock</a>，\n它内置了好用的 <a href=\"http://mockjs.com/\">mock.js</a> ，帮助我们实现快速数据模拟：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">svrx <span class=\"token operator\">--</span>mock <span class=\"token operator\">--</span>route route<span class=\"token punctuation\">.</span>js</code></pre></div>\n<p>直接使用 <code class=\"language-text\">-p mock</code> 或简写<code class=\"language-text\">--mock</code> 来激活这个插件。</p>\n<p><img src=\"https://p1.music.126.net/IdgskBTS6IA668I3h5yXQg==/109951164485717609.png\"></p>\n<p>如上图红框所示，svrx 的插件体系有<strong>首次即安装的特性</strong>，被安装插件会自动进入 svrx 全局管理，<strong>后续激活插件无需重复下载</strong>，更重要的是<strong>不会污染你的工作目录</strong>(包括<code class=\"language-text\">node_modules</code>)。</p>\n<p>在<code class=\"language-text\">route.js</code>中加入以下代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api/user/:id'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>to<span class=\"token punctuation\">.</span><span class=\"token function\">mock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">'@name'</span><span class=\"token punctuation\">,</span>\n  email<span class=\"token punctuation\">:</span> <span class=\"token string\">'@email'</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><em>mock 插件注册了一个名为 mock 的<a href=\"https://docs.svrx.io/zh/guide/route.html#action-%E6%B8%85%E5%8D%95\">路由 Action</a>，可在 Routing DSL 中被使用</em></p>\n<p>再次访问<code class=\"language-text\">/api/user/1</code>，你会得到以下满足一定模式的随机响应，比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"user\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Linda Thomas\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"email\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"g.ykyiexto@toaloso.cc\"</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>除此之外，mock 插件也能快速模拟一些列表循环的逻辑, 比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api/user/:id'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>to<span class=\"token punctuation\">.</span><span class=\"token function\">mock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">'@name'</span><span class=\"token punctuation\">,</span>\n  email<span class=\"token punctuation\">:</span> <span class=\"token string\">'@email'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">'region|1-3'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'@region'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>对应的响应中<code class=\"language-text\">region</code>将会是一个长度是 1 到 3 的地区数组，比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Nancy Allen\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"email\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"aopao@qpo.scm\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"region\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"西北\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"华中\"</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>可以看到使用 <a href=\"https://github.com/svrxjs/svrx-plugin-mock\">mock</a> 插件可以大大提高我们的 mock 效率，并且阅读仍然很直观。</p>\n<h3>使用 json-server 创建基于一定规则的批量接口</h3>\n<p>svrx 的 mock 插件加上内置的动态路由功能基本上能高效的处理 90% 的本地 mock 需求了。</p>\n<p>但如果你的服务是基于 <a href=\"https://github.com/typicode/json-server\">json-server</a> 规范的，你也可以利用 <a href=\"https://github.com/svrxjs/svrx-plugin-json-server\">svrx-plugin-json-server</a> 来快速实现海量接口，让我们一起来试下吧。</p>\n<p>首先在当前目录创建如下内容的 <code class=\"language-text\">db.json</code> 文件：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"posts\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span> <span class=\"token property\">\"id\"</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token property\">\"title\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"json-server\"</span><span class=\"token punctuation\">,</span> <span class=\"token property\">\"author\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"typicode\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"comments\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span> <span class=\"token property\">\"id\"</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token property\">\"body\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"some comment\"</span><span class=\"token punctuation\">,</span> <span class=\"token property\">\"postId\"</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>启动 svrx 并激活 <code class=\"language-text\">json-server</code> 插件：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">svrx <span class=\"token operator\">-</span>p json<span class=\"token operator\">-</span>server <span class=\"token operator\">--</span>route route<span class=\"token punctuation\">.</span>js</code></pre></div>\n<p>与 mock 类似，json-server 插件会注册一个名为 <code class=\"language-text\">jsonServer</code> 的<a href=\"https://docs.svrx.io/zh/guide/route.html#action-%E6%B8%85%E5%8D%95\">路由 Action</a>。</p>\n<p>在<code class=\"language-text\">route.js</code> 加入以下配置：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">route</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/(.*)'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>to<span class=\"token punctuation\">.</span><span class=\"token function\">jsonServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>以上语句会将所有请求直接代理到内部的 json-server 模块。</p>\n<p>访问 <code class=\"language-text\">/posts</code>, 将看到如下响应：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span>\n    id<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n    title<span class=\"token punctuation\">:</span> <span class=\"token string\">'json-server'</span><span class=\"token punctuation\">,</span>\n    author<span class=\"token punctuation\">:</span> <span class=\"token string\">'typicode'</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>值得一提的是，其实 json-server 内置了全部 crud 操作，以<code class=\"language-text\">posts</code>为例：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">POST /posts        <span class=\"token operator\">=</span><span class=\"token operator\">></span> Create 即创建操作\nUPDATE /posts/:id  <span class=\"token operator\">=</span><span class=\"token operator\">></span> UPDATE 即更新操作\nGET /posts/:id     <span class=\"token operator\">=</span><span class=\"token operator\">></span> READ 即读操作\nGET /posts         <span class=\"token operator\">=</span><span class=\"token operator\">></span> READ LIST 即列表读操作\nDELETE /posts/:id  <span class=\"token operator\">=</span><span class=\"token operator\">></span> DELETE 即删除操作</code></pre></div>\n<p>举个栗子，当你发起一个<strong>创建</strong>请求(以前端 fetch 为例):</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/posts'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  method<span class=\"token punctuation\">:</span> <span class=\"token string\">'POST'</span><span class=\"token punctuation\">,</span>\n  body<span class=\"token punctuation\">:</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> title<span class=\"token punctuation\">:</span> <span class=\"token string\">'svrx'</span><span class=\"token punctuation\">,</span> author<span class=\"token punctuation\">:</span> <span class=\"token string\">'x-orpheus'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  headers<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">'content-type'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'application/json'</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>你再访问 <code class=\"language-text\">/posts</code> 列表，会发现多了一条记录，<strong>且这条记录会同步持久化到<code class=\"language-text\">db.json</code></strong>:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span>\n    id<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n    title<span class=\"token punctuation\">:</span> <span class=\"token string\">'json-server'</span><span class=\"token punctuation\">,</span>\n    author<span class=\"token punctuation\">:</span> <span class=\"token string\">'typicode'</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span>\n    title<span class=\"token punctuation\">:</span> <span class=\"token string\">'svrx'</span><span class=\"token punctuation\">,</span>\n    author<span class=\"token punctuation\">:</span> <span class=\"token string\">'x-orpheus'</span><span class=\"token punctuation\">,</span>\n    id<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>请求改写</strong></p>\n<p>通过串连路由的 rewrite 指令，我们可以做到只引导部分流量到 json-server 服务，例如:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">route</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api/(.*)'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">rewrite</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/{0}'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span>to<span class=\"token punctuation\">.</span><span class=\"token function\">jsonServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// /api/posts => /posts</span></code></pre></div>\n<p>这样只有<code class=\"language-text\">/api</code>开头的请求会代理到 json-server，其他请求可以走其他的 mock 逻辑。</p>\n<h3>使用接口管理平台</h3>\n<p>以上所有的 mock 方式其实都有一个较大的问题，就是 mock 规则都是在本地的，我们无法共享配置。</p>\n<p>而实际上较大的团队都应该有 API 接口管理平台来统一管理接口定义，在网易我们使用<a href=\"https://nei.netease.com/\"><strong>NEI：接口管理平台</strong></a>来管理 API(由云音乐前端团队维护，欢迎免费试用)。\n一般这类平台都有接口模拟功能，代理到这类平台，我们可以轻松实现规范化的接口 mock：</p>\n<p><img src=\"https://p1.music.126.net/kDpS2jjo8fyuCojePmyOiA==/109951164485054793.png\"></p>\n<p>搭配这种接口管理平台，云音乐团队也封装了 svrx-plugin-nei (即将开源)来实现代理到 NEI 平台的数据模拟，如下图所示:</p>\n<p><img src=\"https://p1.music.126.net/nC_EwzTKSTrvLJDBz4X6EQ==/109951164495913863.png\"></p>\n<p>基于接口管理平台的接口模拟是与真实接口规范匹配的，所以<strong>前后端规范性会更一致</strong>，并且它的平台属性也<strong>方便开发者共享配置</strong>。\n但这种方式也有巨大的劣势，就是<strong>灵活度远低于本地接口模拟</strong>。</p>\n<p>值得一提的是<strong>此插件利用 svrx 的前端注入能力实现了跨浏览器的前端配置界面</strong>，\nsvrx 通过内部 injector 模块自动为响应是 html 类型的资源注入种子脚本，种子脚本会集成所有 plugin 注册的脚本内容，从而实现了前端逻辑在 dev-server 侧的注入。</p>\n<h3>通过 mock 解析 svrx 的核心价值</h3>\n<p>我们可以看到，以上所有特性在数据 Mock 领域都是功能互补的，没有所谓的万金油方案。</p>\n<p>所以 svrx 带给我们其实并不是 <code class=\"language-text\">svrx-plugin-mock</code>、<code class=\"language-text\">svrx-plugin-json-server</code>亦或是<code class=\"language-text\">svrx-plugin-nei</code> 等等这些隔离的单一功能，\n而是基于 svrx 这个平台，我们可以很容易的将这些围绕在<code class=\"language-text\">dev-server</code>领域的功能以<strong>一种统一的方式集成起来使用，避免重复的安装和配置工作</strong>。</p>\n<p>举个栗子 🌰，当开发者希望 JSON 响应的格式输出更好看时，可以直接使用<code class=\"language-text\">-p json-viewer</code>来激活对应插件：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">svrx <span class=\"token operator\">--</span>route router<span class=\"token punctuation\">.</span>js \\\n  <span class=\"token operator\">-</span>p json<span class=\"token operator\">-</span>viewer \\\n  <span class=\"token operator\">-</span>p json<span class=\"token operator\">-</span>server \\\n  <span class=\"token operator\">-</span>p mock</code></pre></div>\n<p>响应视图立刻从下面的无序纯文本：</p>\n<p><img src=\"https://p1.music.126.net/qhhXtG840eDTslVqd1BfUQ==/109951164481900789.png?param=600x0\"></p>\n<p>无缝切换为直观的下图：</p>\n<p><img src=\"https://p1.music.126.net/whNJnacw5VERC5on6HR8xA==/109951164485027828.png?param=400x0\"></p>\n<p>再举个栗子 🌰，当我们想将我们的本地服务暴露到外网使用时，可以使用 <code class=\"language-text\">-p localtunnel</code> 激活 <a href=\"https://github.com/localtunnel/localtunnel\">localtunnel</a> 的反向隧道网关服务。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">svrx <span class=\"token operator\">--</span>route route<span class=\"token punctuation\">.</span>js \\\n  <span class=\"token operator\">-</span>p json<span class=\"token operator\">-</span>viewer \\\n  <span class=\"token operator\">-</span>p json<span class=\"token operator\">-</span>server \\\n  <span class=\"token operator\">-</span>p mock \\\n  <span class=\"token operator\">-</span>p <span class=\"token string\">\"localtunnel?host=https://tunnel.svrx.io\"</span></code></pre></div>\n<blockquote>\n<ul>\n<li><em>参数过长时可以使用 <a href=\"https://docs.svrx.io/zh/quick-start.html#%E9%85%8D%E7%BD%AE%E6%8C%81%E4%B9%85%E5%8C%96\">svrx 配置文件</a>中</em></li>\n<li>tunnel.svrx.io 是属于福利性设施，不确保稳定性，请大家悠着点使用以避免服务因为各种原因不可用。</li>\n</ul>\n</blockquote>\n<p><img src=\"https://p1.music.126.net/mh0fszeEfluJ5Ocp_JVEcQ==/109951164485983063.png\"></p>\n<p>上图类似 <a href=\"https://fast-dragon-86.tunnel.svrx.io\">https://fast-dragon-86.tunnel.svrx.io</a> 的随机地址即可用于外网访问的域名了，这种即开即走的使用体验是碎片化的各种 dev server 平台无法提供给你的。</p>\n<p>更重要的是，接口 mock 其实仅仅只是我们日常开发中的一环，<strong>svrx 的定位是一个通用开发服务器</strong>，它内置集成了<code class=\"language-text\">serve</code>、<code class=\"language-text\">proxy</code>、<code class=\"language-text\">livereload</code>、<code class=\"language-text\">route</code>等等日常前端开发中必不可少的功能，\n并且可以通过社区<a href=\"https://svrx.io/plugin?query=svrx-plugin-\">不断增加的插件池</a>来进行自由组合使用，这个我们从上述接口 mock 这一场景的描述中应该已经看到。</p>\n<p>完全可以这么说，<strong>围绕 dev-server 的设施越多，svrx 存在的价值就越大</strong></p>\n<h2>写在最后</h2>\n<p>除了完全不推荐的「硬编码方案」之外，做到与业务代码解耦的「纯前端拦截」和「纯后端拦截」的接口 mock 方案也都存在一些无法规避的本质性问题。</p>\n<p>而使用 svrx 以及它配套的社区插件，我们除了可以整合前端和后端拦截的优势，还可以将各种 mock 功能集成在一个服务中运行，解决了工具的碎片化问题，从而高效的实现接口 mock 需求。</p>\n<h2>Links</h2>\n<ul>\n<li><a href=\"https://docs.svrx.io/zh/\"><strong>svrx（读音:Server-X）</strong></a> 是一个渐进且易于使用的、插件化的前端开发服务器。</li>\n<li><a href=\"https://juejin.im/post/5dad208ef265da5b7d692340\">Server-X：一款可能提升你十倍工作效率的工具</a></li>\n<li><a href=\"http://mockjs.com/\">mock.js</a>(前端 mock 工具库)以及对应的<a href=\"https://github.com/svrxjs/svrx-plugin-mock\">svrx-plugin-mock</a>插件</li>\n<li><a href=\"https://github.com/typicode/json-server\">json-server</a>: Get a full fake REST API with zero coding in less than 30 seconds (seriously)</li>\n<li><a href=\"https://github.com/localtunnel/localtunnel\">localtunnel</a>: 一个反向隧道服务，用来暴露本地服务到公网域名，这里也有<a href=\"https://github.com/x-orpheus/localtunnel-server\">团队整理的 docker 快捷部署方案</a></li>\n<li><a href=\"https://nei.netease.com/\">NEI 接口管理平台</a>: 网易研发团队都在使用的接口管理平台</li>\n<li><a href=\"https://koajs.com\">Koa</a>: 一个轻量级的 Nodejs 框架</li>\n<li>\n<p>官方微信群: 已满百人请加微信号 cyxu0825 (项目Owner) 进群</p>\n<p><img src=\"https://p1.music.126.net/d1VyRRgxIWG44xNRSGm-Tw==/109951164498053449.png?param=200x0\"></p>\n</li>\n</ul>\n<blockquote>\n<p>本文发布自 <a href=\"https://github.com/x-orpheus\">网易云音乐前端团队</a>，文章未经授权禁止任何形式的转载。我们一直在招人，如果你恰好准备换工作，又恰好喜欢云音乐，那就 <a href=\"mailto:grp.music-fe@corp.netease.com\">加入我们</a>！</p>\n</blockquote>","frontmatter":{"title":"使用 svrx 实现更优雅的接口 Mock","date":"2019-11-20","description":"目前 Web 开发普遍都切换到了前后端分离的开发模式。虽然在工程和职能上已经分离了，但在实际工作中，前后端在开发进度上往往会出现不一致的情况，此时就会极大地影响开发效率。 接口 mock 在此时就发挥出了巨大价值，它磨平了这个时间差，最终实现高效的前后端分离开发。"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/svrx-mock/","previous":{"fields":{"slug":"/lighthouse/"},"frontmatter":{"title":"Lighthouse 测试内幕"}},"next":{"fields":{"slug":"/docker-and-kubernetes/"},"frontmatter":{"title":"前端领域的 Docker 与 Kubernetes"}}}}}