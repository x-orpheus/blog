{"componentChunkName":"component---src-templates-blog-post-js","path":"/javascript-functional-programming-functor/","webpackCompilationHash":"95f1de1856b8b6766301","result":{"data":{"site":{"siteMetadata":{"title":"云音乐大前端专栏","author":"云音乐大前端团队","siteUrl":"https://musicfe.dev"}},"markdownRemark":{"id":"10c59e9c-6676-5c60-a970-1d3dec7fe438","excerpt":"pipeline & function compose 图片来源: https://unsplash.com/photos/FqYMtQpE77E 本文作者：赵祥涛 上一章中介绍了  的概念，简单来说，就是把一个 “value” 填装进 “Box” 中，继而可以使用  方法映射变换 Box…","html":"<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/4602192261/a2a1/eb82/07ae/9ebb494ff96b26c7ae6ab0366663da51.png\" alt=\"pipeline &#x26; function compose\"></p>\n<p>图片来源: <a href=\"https://unsplash.com/photos/FqYMtQpE77E\">https://unsplash.com/photos/FqYMtQpE77E</a></p>\n<blockquote>\n<p>本文作者：<a href=\"https://github.com/sylvenas\">赵祥涛</a></p>\n</blockquote>\n<p><a href=\"https://musicfe.dev/javascript-functional-programming-advance/\">上一章</a>中介绍了 <code class=\"language-text\">Functor(函子)</code> 的概念，简单来说，就是把一个 “value” 填装进 “Box” 中，继而可以使用 <code class=\"language-text\">map</code> 方法映射变换 Box 中的值：<code class=\"language-text\">Box(1).map(x =&gt; x+1)</code>。本章我们在继续在 <code class=\"language-text\">Box</code> 的基础上继续扩展其他更强大的理念，从<a href=\"https://en.wikipedia.org/wiki/Pure_function\">纯函数</a>与<a href=\"https://en.wikipedia.org/wiki/Side_effect_(computer_science)\">副作用</a>的概念及用途作为承上启下的开端，继续巩固 <code class=\"language-text\">Functor</code> 的概念以及接下来将要介绍的 <code class=\"language-text\">Applicative Functor</code> 的引子。</p>\n<p>函数式编程中纯函数是一个及其重要的概念，甚至可以说是函数组合的基础。你可能已经听过类似的言论：“纯函数是引用透明( Referential Transparency )的”，“纯函数是无副作用( Side Effect )的”，“纯函数没有共享状态( Shared State )”。下面简单介绍下纯函数。</p>\n<h3>纯函数与副作用</h3>\n<p>在计算机编程中，假如满足下面这两个条件的约束，一个函数可以被描述为一个“纯函数”( pure function )</p>\n<ul>\n<li>给出相同的参数，那么函数的返回值一定相同。该函数结果值不依赖任何隐藏信息或程序执行处理可能改变的状态，也不能依赖于任何来自 I/O 的外部输入。</li>\n<li>在对函数返回值的计算过程中，不会产生任何语义上可观察的副作用或输出，例如对象的变化或者输出到 I/O 的操作。</li>\n</ul>\n<p>关于纯函数的第一条很简单，相同的输入，总会返回相同的输出，和中学数学中学习的“函数”完全类似，传入相同的参数，返回值一定相同，函数本身就是从集合到集合的“映射”。</p>\n<p>第二条不产生可观察的副作用又是什么意思呢？也就是函数不可以和系统的其他部分通信。比如：打印日志，读写文件，数据请求，数据存储等等；</p>\n<p>从代码编写者的角度来看，如果一段程序运行之后没有可观察到的作用，那他到底运行了没有？或者运行之后有没有实现代码的目的？有可能它只是浪费了几个 CPU 周期之后就去睡大觉了！</p>\n<p>从 JavaScript 语言的诞生之初就不可避免地需要能够与不断变化的，共享的，有状态的 DOM 互相作用；如果无法输入输出任何数据，那么数据库有什么用处呢？如果无法从网络请求信息，我们的页面又该如何展示？没有 “side effect” 我们几乎寸步难行，<strong>副作用不可避免</strong>，上述的任何一个操作，都会产生副作用，违反了引用透明性，我们似乎陷入了两难的境地！</p>\n<blockquote>\n<p>世間安得雙全法，不負如來不負卿</p>\n</blockquote>\n<p><strong>如何在 <code class=\"language-text\">keep pure</code> 的前提下，又能妥善的处理 <code class=\"language-text\">side effect</code> 呢？</strong></p>\n<h3>惰性盒子-LazyBox</h3>\n<p>要想较理想的解决这个问题，我们把注意力转回到 JavaScript 的核心 function 上，我们知道在 JavaScript 里，函数是“一等公民”，JavaScript 允许开发人员像操作变量一样操作函数，例如将函数赋值给变量、把函数作为参数传递给其他函数、函数作为另一个函数的返回值，等等...</p>\n<p>JavaScript 函数具有<strong>值的行为</strong>，也就是说，函数就是一个基于输入的且尚未求值的不可变的值，或者可以认为函数本身就是一个等待计算的惰性的值。那么我们完全可以把这个“惰性的值”装入 <code class=\"language-text\">Box</code> 中，然后延迟调用即可，仿照上一章的 <code class=\"language-text\">Box</code> ，可以实现一个 <code class=\"language-text\">Lazy Box</code> ：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">LazyBox</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">g</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">map</span><span class=\"token punctuation\">:</span> <span class=\"token parameter\">f</span> <span class=\"token operator\">=></span> <span class=\"token function\">LazyBox</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token function\">g</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function-variable function\">fold</span><span class=\"token punctuation\">:</span> <span class=\"token parameter\">f</span> <span class=\"token operator\">=></span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token function\">g</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>注意观察，<strong>map 函数所做的一直都是在组合函数，函数并没有被实际的调用；而调用 fold 函数才会真正的执行函数调用</strong>，看例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">finalPrice</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">str</span> <span class=\"token operator\">=></span>\n    <span class=\"token function\">LazyBox</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> str<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'str:'</span><span class=\"token punctuation\">,</span> str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">return</span> x <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">*</span> <span class=\"token number\">0.8</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">-</span> <span class=\"token number\">50</span><span class=\"token punctuation\">)</span>  \n\n<span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token function\">finalPrice</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span>  <span class=\"token comment\">// => { map: [Function: map], fold: [Function: fold] }</span></code></pre></div>\n<p>在调用 <code class=\"language-text\">finalPrice</code> 函数的时候，并没有打印出 <code class=\"language-text\">&#39;str:100&#39;</code>，说明正如我们预期的那样，函数并没有真正的被调用，而只是在不断的进行函数组合。在没有调用 <code class=\"language-text\">fold</code> 函数之前，我们的代码都是 \"pure\" 的。</p>\n<blockquote>\n<p>这有点类似于递归，在未满足终止条件之前(没有调用 <code class=\"language-text\">fold</code> 之前)，递归调用会在栈中不断的堆叠(组合函数)，直到满足终止条件(调用 <code class=\"language-text\">fold</code> 函数)，才开始真正的函数计算。</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> app <span class=\"token operator\">=</span> <span class=\"token function\">finalPrice</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> res2 <span class=\"token operator\">=</span> app<span class=\"token punctuation\">.</span><span class=\"token function\">fold</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x<span class=\"token punctuation\">)</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res2<span class=\"token punctuation\">)</span> <span class=\"token comment\">// => 110</span></code></pre></div>\n<p><code class=\"language-text\">fold</code> 函数就像打开潘多拉魔盒的双手；通过 <code class=\"language-text\">LazyBox</code> 我们把可能会“弄脏双手(产生副作用)”的代码扔给了最后的 <code class=\"language-text\">fold</code> ，这样做又有什么意义呢？</p>\n<ul>\n<li>把代码中不纯的部分剥离出来，保障核心部分代码的 “pure” 特性，比如上面的代码中只有 <code class=\"language-text\">app.fold(x =&gt; x)</code> 是 “no pure” 的，其他部分都是 “pure” </li>\n<li>类似于上一章中的错误集中管理，可以通过 <code class=\"language-text\">LazyBox</code> 来把副作用集中管理，如果在项目中不断的扩大 “pure” 的部分，我们甚至可以把不纯的代码推到代码的边缘，保证核心部分的 “pure” 和 “referential transparency” </li>\n</ul>\n<blockquote>\n<p>LazyBox 也和 Rxjs 中的 <code class=\"language-text\">Observable</code> 有很多相似之处，两者都是惰性的，在 <code class=\"language-text\">subscribe</code> 之前，<code class=\"language-text\">Observable</code> 也不会推送数据。</p>\n</blockquote>\n<blockquote>\n<p>此处请思考下 React 中的 <code class=\"language-text\">useEffect</code> 以及 Redux 中的 <code class=\"language-text\">reducer</code> ，<code class=\"language-text\">action</code> 分离的设计理念。</p>\n</blockquote>\n<h3>应用函子</h3>\n<h4>Function in Box</h4>\n<p>上一小结，介绍了把函数装入 <code class=\"language-text\">LazyBox</code> 中，放在最后延迟执行，以保障最后大多数代码的 “pure” 特性。</p>\n<p>转换下思维，函数可以认为是“惰性的值”，那么我们把这个稍显特殊的值，装入普通的 <code class=\"language-text\">Box</code> ，又会发生什么呢？还是从小学数学开始吧。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Box</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">map</span><span class=\"token punctuation\">:</span> <span class=\"token parameter\">f</span> <span class=\"token operator\">=></span> <span class=\"token function\">Box</span><span class=\"token punctuation\">(</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function-variable function\">inspect</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Box(</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>x<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">)</span><span class=\"token template-punctuation string\">`</span></span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">addOne</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n<span class=\"token function\">Box</span><span class=\"token punctuation\">(</span>addOne<span class=\"token punctuation\">)</span> <span class=\"token comment\">// => Box(x => x + 1)</span></code></pre></div>\n<blockquote>\n<p><code class=\"language-text\">inspect</code> 方法的目的是为了使用 Node.js 中的 <code class=\"language-text\">console.log</code> 隐式的调用它，方便我们查看数据的类型；而这一方法在浏览器中不可行，可以用 <code class=\"language-text\">console.log(String(x))</code> 来代替; Node.js V12 API 有变更，可以采用 <code class=\"language-text\">Symbol.for(&#39;nodejs.util.inspect.custom&#39;)</code> 替代 <code class=\"language-text\">inspect</code></p>\n</blockquote>\n<p>现在我们得到了一个包裹着函数的 <code class=\"language-text\">Box</code> ，可是我们怎么使用这个函数呢？毕竟 <code class=\"language-text\">Box(x).map</code> 方法都是接收一个函数！继续回到函数 <code class=\"language-text\">addOne</code> 上，我们需要一个数字，传递给 <code class=\"language-text\">addOne</code> ，对吧！所以换句话说就是，我们怎么传递一个数字进去应用这个 <code class=\"language-text\">addOne</code> 函数呢，答案非常简单，继续传递一个被包裹的值，然后 <code class=\"language-text\">map</code> 这个函数 (<code class=\"language-text\">addOne</code>) 不就可以啦! 看代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Box</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">map</span><span class=\"token punctuation\">:</span> <span class=\"token parameter\">f</span> <span class=\"token operator\">=></span> <span class=\"token function\">Box</span><span class=\"token punctuation\">(</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function-variable function\">apply</span><span class=\"token punctuation\">:</span> <span class=\"token parameter\">o</span> <span class=\"token operator\">=></span> o<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function-variable function\">flod</span><span class=\"token punctuation\">:</span> <span class=\"token parameter\">f</span> <span class=\"token operator\">=></span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function-variable function\">inspect</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Box(</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>x<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">)</span><span class=\"token template-punctuation string\">`</span></span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">Box</span><span class=\"token punctuation\">(</span>addOne<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token function\">Box</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// => Box(3)</span></code></pre></div>\n<p>看看 Box 神奇的新方法，首先被包裹的值是一个<strong>函数 x</strong> ，然后我们继续传递另一个 <code class=\"language-text\">Box(2)</code> 进去，不就可以使用 <code class=\"language-text\">Box(2)</code> 上的 <code class=\"language-text\">map</code> 方法调用 <code class=\"language-text\">addOne</code> 函数了吗！</p>\n<p>现在重新审视一下我们 <code class=\"language-text\">Box(addOne)</code> ，<code class=\"language-text\">Box(1)</code> ，那么这个问题实际上可以归结为：把一个 <code class=\"language-text\">functor</code> 应用到另一个上 <code class=\"language-text\">functor</code> 上，而这也就是 <code class=\"language-text\">Applicative Functor</code> (应用函子)最擅长的操作了，看一下示意图来描述应用函子的操作流程：</p>\n<p><img src=\"https://p1.music.126.net/kfldU46LvUhUaY_QjP6LHw==/109951164712439705.png\" alt=\"Applicative Functor\"></p>\n<p>所以根据上面的讲解和实例我们可以得出一个结论：先把一个值 <code class=\"language-text\">x</code> 装进 <code class=\"language-text\">Box</code>，然后 <code class=\"language-text\">map</code> 一个函数 <code class=\"language-text\">f</code>  和把函数 <code class=\"language-text\">f</code> 装进 <code class=\"language-text\">Box</code>，然后 <code class=\"language-text\">apply</code> 一个已经已经装进 <code class=\"language-text\">Box</code> 的 <code class=\"language-text\">x</code>，是完全等价的！</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token constant\">F</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token constant\">F</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ap</span><span class=\"token punctuation\">(</span><span class=\"token constant\">F</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">Box</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>addOne<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token function\">Box</span><span class=\"token punctuation\">(</span>addOne<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token function\">Box</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// => Box(3)</span></code></pre></div>\n<blockquote>\n<p>根据<a href=\"https://github.com/fantasyland/fantasy-land#applicative\">规范</a>，apply 方法后面我们会简写为<code class=\"language-text\">ap</code>!</p>\n</blockquote>\n<blockquote>\n<p><code class=\"language-text\">Applicative functor (应用函子)</code> 也是函数式编程中一大堆“故弄玄虚”的概念中唯一的比较“名副其实”的了，想想 <code class=\"language-text\">Functor(函子)</code></p>\n</blockquote>\n<h4>应用函子与函数柯里化</h4>\n<p>在继续学习函数柯里化之前，先复习一下中学数学中的高斯消元法：设函数 <code class=\"language-text\">f(x,y) = x + y</code>，在 <code class=\"language-text\">y = 1</code> 的时候，函数可以修改为 <code class=\"language-text\">f(x) = x + 1</code> 。基本思路就是把二元变成一元，同理我们可以把三元函数降元为二元，甚至把多元函数降元为一元函数。   </p>\n<p>那么我们可以在一定程度上认为函数求值的过程，就是就是函数消元的过程，当所有的元都被消完之后，那么就可以求的函数值。</p>\n<p>数学中的高斯消元法和函数式编程中的“柯里化”是有点类似的，所谓函数柯里化就是把一个接收多个参数的函数，转换为一次接收一个参数，直到收到全部参数之后，进行函数调用(计算函数值)，看例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">add</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">,</span> y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> y\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">curriedAdd</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> <span class=\"token parameter\">y</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> y</code></pre></div>\n<p>好了，简单理解了函数柯里化的概念之后，继续往前走一步，思考一下，如果现在有两个「被包裹的值」，怎么把一个函数应用上去呢？举个例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">add</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> <span class=\"token parameter\">y</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> y\n\n<span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token function\">Box</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token function\">Box</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>上面的方案明显是走不通的，我们没办法直接把  <code class=\"language-text\">Box(1)</code> 和 <code class=\"language-text\">Box(2)</code> 相加，他们都在盒子里; </p>\n<p>可是我们的需求不就是把 <code class=\"language-text\">Box(1)</code> ，<code class=\"language-text\">Box(2)</code>，<code class=\"language-text\">add</code> 三者互相应用一下，想要得到最后的结果 <code class=\"language-text\">Box(3)</code>。</p>\n<p>从第一章开始，我们的函数运算都是在 Box 的“保护”下进行的，现在不妨也把 <code class=\"language-text\">add</code> 函数包装进 Box 中，不就得到了一个应用函子 <code class=\"language-text\">Box(add)</code>，然后继续 “apply” 其他的函子了吗？</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">Box</span><span class=\"token punctuation\">(</span>add<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ap</span><span class=\"token punctuation\">(</span><span class=\"token function\">Box</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// => Box(y => 1 + y) (得到另一个应用函子)</span>\n<span class=\"token function\">Box</span><span class=\"token punctuation\">(</span>add<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ap</span><span class=\"token punctuation\">(</span><span class=\"token function\">Box</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ap</span><span class=\"token punctuation\">(</span><span class=\"token function\">Box</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// => Box(3) (得到最终的结果)</span></code></pre></div>\n<p>上面的例子，因为每次 <code class=\"language-text\">apply</code> 一个 <code class=\"language-text\">functor</code> ，相当于把函数降元一次，我们可以得出一个结论，<strong>一个柯里化的函数，有几个参数，我们就可以 apply 几次</strong>。</p>\n<blockquote>\n<p>每次 apply 之后都会返回包裹新函数的应用函子，换句话说就是：应用多个数据到多个函数，这和多重循环非常类似。</p>\n</blockquote>\n<h3>应用函子的应用案例</h3>\n<p>表单校验是我们日常开发中常见的一个需求，举个具体的例子，假如我们有一个用户注册的表单，我们需要校验用户名，密码两个字段，常见的代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">checkUserInfo</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">user</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">,</span> pw<span class=\"token punctuation\">,</span> phone <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> user\n    <span class=\"token keyword\">const</span> errInfo <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token regex\">/^[0-9].+$/</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        errInfo<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token string\">'用户名不能以数字开头'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pw<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&lt;=</span> <span class=\"token number\">6</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        errInfo<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token string\">'密码长度必须大于6位'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>errInfo<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> errInfo\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> userInfo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    name<span class=\"token punctuation\">:</span> <span class=\"token string\">'1Melo'</span><span class=\"token punctuation\">,</span>\n    pw<span class=\"token punctuation\">:</span> <span class=\"token string\">'123456'</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> checkRes <span class=\"token operator\">=</span> <span class=\"token function\">checkUserInfo</span><span class=\"token punctuation\">(</span>userInfo<span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>checkRes<span class=\"token punctuation\">)</span>  <span class=\"token comment\">// => [ '用户名不能以数字开头', '密码长度必须大于6位' ]</span></code></pre></div>\n<p>这个代码自然没有问题，但是，假如我们要继续添加需要校验的字段(e.g.,电话号码，邮箱)， <code class=\"language-text\">checkUserInfo</code> 函数毫无疑问会越来越庞大，并且如果我们要修改某一个字段的校验规则的话，整个 <code class=\"language-text\">checkUserInfo</code> 函数可能会受到影响，我们需要增加的单元测试工作要更多了。</p>\n<p>回想一下第一章中介绍的 Either(Left or Rigth) <code class=\"language-text\">Right</code> 指代正常的分支，<code class=\"language-text\">Left</code> 指代出现异常的分支，他们两者绝不会同时出现，现在我们稍微换个理解方式：<code class=\"language-text\">Right</code> 指代校验通过的分支，<code class=\"language-text\">Left</code> 指代校验不通过的分支。</p>\n<p>此时我们继续在第一章 Either 的基础上扩展其他的属性和方法，用来做表单校验的工具：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Right</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    x<span class=\"token punctuation\">,</span>\n    <span class=\"token function-variable function\">map</span><span class=\"token punctuation\">:</span> <span class=\"token parameter\">f</span> <span class=\"token operator\">=></span> <span class=\"token function\">Right</span><span class=\"token punctuation\">(</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function-variable function\">ap</span><span class=\"token punctuation\">:</span> <span class=\"token parameter\">o</span> <span class=\"token operator\">=></span> o<span class=\"token punctuation\">.</span>isLeft <span class=\"token operator\">?</span> o <span class=\"token punctuation\">:</span> o<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function-variable function\">fold</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">f<span class=\"token punctuation\">,</span> g</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    isLeft<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n    isRight<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function-variable function\">inspect</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Right(</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>x<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">)</span><span class=\"token template-punctuation string\">`</span></span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Left</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    x<span class=\"token punctuation\">,</span>\n    <span class=\"token function-variable function\">map</span><span class=\"token punctuation\">:</span> <span class=\"token parameter\">f</span> <span class=\"token operator\">=></span> <span class=\"token function\">Left</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function-variable function\">ap</span><span class=\"token punctuation\">:</span> <span class=\"token parameter\">o</span> <span class=\"token operator\">=></span> o<span class=\"token punctuation\">.</span>isLeft <span class=\"token operator\">?</span> <span class=\"token function\">Left</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token function\">Left</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function-variable function\">fold</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">f<span class=\"token punctuation\">,</span> g</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    isLeft<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    isRight<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function-variable function\">inspect</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Left(</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>x<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">)</span><span class=\"token template-punctuation string\">`</span></span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>相对比与原 <code class=\"language-text\">Either</code>，新增了 <code class=\"language-text\">x</code> 属性和 <code class=\"language-text\">ap</code> 方法，其他的属性完全类似，就不做解释了；新增 <code class=\"language-text\">x</code> 属性的原因在于需要记录表单校验的错误信息，这个很好理解，而新增的 <code class=\"language-text\">isLeft</code> ，<code class=\"language-text\">isRight</code> 属性就更简单了，用来区分 <code class=\"language-text\">Left/Right</code> 分支。 </p>\n<p>我们仔细看一下新增的 <code class=\"language-text\">ap</code> 方法，先看 <code class=\"language-text\">Right</code> 分支的 <code class=\"language-text\">ap: o =&gt; o.isLeft ? o : o.map(x)</code>，毫无疑问 <code class=\"language-text\">ap</code> 方法接收另一个 <code class=\"language-text\">functor</code> ，如果另一个 <code class=\"language-text\">functor</code> 是 <code class=\"language-text\">Left</code> 的实例，则不需要 <code class=\"language-text\">Right</code> 处理直接返回，如果是 <code class=\"language-text\">Right</code> ，则和平常 <code class=\"language-text\">applicative functor</code> 一样，对 <code class=\"language-text\">o</code> 作为主体进行 <code class=\"language-text\">map</code>。</p>\n<p><code class=\"language-text\">Left</code> 分支上的 <code class=\"language-text\">ap: o =&gt; o.Left ? Left(x.concat(o.x)) : Left(x)</code>，如果是 <code class=\"language-text\">Left</code> 的实例，则进行一个“叠加”，实际上就是为了累加错误信息，而如果不是 <code class=\"language-text\">Left</code> 的实例则直接返回原本已经记录的错误信息。</p>\n<p>做好了前期的准备工作，我们就可以大刀阔斧的按照函数式的思维(函数组合)来拆分一下 <code class=\"language-text\">checkUserInfo</code> 函数：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">checkName</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">name</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">/</span><span class=\"token operator\">^</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token operator\">-</span><span class=\"token number\">9</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token operator\">+</span>$<span class=\"token operator\">/</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token function\">Left</span><span class=\"token punctuation\">(</span><span class=\"token string\">'用户名不能以数字开头'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token function\">Right</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">checkPW</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">pw</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> pw<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&lt;=</span> <span class=\"token number\">6</span> <span class=\"token operator\">?</span> <span class=\"token function\">Left</span><span class=\"token punctuation\">(</span><span class=\"token string\">'密码长度必须大于6位'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token function\">Right</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面把两个字段校验从一个函数中拆分成了两个函数，更重要的是完全解耦；返回值要么是校验不通过的 <code class=\"language-text\">Left</code> ，要么是校验通过的 <code class=\"language-text\">Right</code> ，所以我们可以理解为现在有了两个 <code class=\"language-text\">Either</code>，只要我们再拥有一个 <strong>被包裹进Either盒子并且柯里化两次的函数</strong> 不就可以让他们互相 apply 了吗？</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token constant\">R</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ramda'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">success</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token boolean\">true</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">checkUserInfo</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">user</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">,</span> pw<span class=\"token punctuation\">,</span> phone <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> user\n    <span class=\"token comment\">// 2 是因为我们需要 `ap` 2 次。</span>\n    <span class=\"token keyword\">const</span> returnSuccess <span class=\"token operator\">=</span> <span class=\"token constant\">R</span><span class=\"token punctuation\">.</span><span class=\"token function\">curryN</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> success<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token function\">Right</span><span class=\"token punctuation\">(</span>returnSuccess<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">ap</span><span class=\"token punctuation\">(</span><span class=\"token function\">checkName</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">ap</span><span class=\"token punctuation\">(</span><span class=\"token function\">checkPW</span><span class=\"token punctuation\">(</span>pw<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> checkRes <span class=\"token operator\">=</span> <span class=\"token function\">checkUserInfo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">:</span> <span class=\"token string\">'1Melo'</span><span class=\"token punctuation\">,</span> pw<span class=\"token punctuation\">:</span> <span class=\"token string\">'123456'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>checkRes<span class=\"token punctuation\">)</span> <span class=\"token comment\">// => Left(用户名不能以数字开头密码长度必须大于6位)</span>\n\n<span class=\"token keyword\">const</span> checkRes2 <span class=\"token operator\">=</span> <span class=\"token function\">checkUserInfo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">:</span> <span class=\"token string\">'Melo'</span><span class=\"token punctuation\">,</span> pw<span class=\"token punctuation\">:</span> <span class=\"token string\">'1234567'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>checkRes2<span class=\"token punctuation\">)</span> <span class=\"token comment\">// => Right(true)</span></code></pre></div>\n<p>现在 <code class=\"language-text\">checkUserInfo</code> 函数的返回值是一个 Either(Left or Righr) 函子，具体后面就可以继续使用 <code class=\"language-text\">fold</code> 函数，展示校验不通过弹窗或者进行下一步的表单提交了。</p>\n<blockquote>\n<p>关于校验参数使用 <a href=\"https://codurance.com/2018/01/11/applicatives-validation/\">Validation</a> 函子更合适 ，这里为了聚焦讲解 Applicative Functor 理念这条主干线，就不再继续引入新概念了。</p>\n</blockquote>\n<h3>PointFree风格</h3>\n<p>上面举例说明的 <code class=\"language-text\">checkUserInfo</code> 函数，需要 <code class=\"language-text\">ap</code> 两次，感觉有点繁琐(想想如果我们需要校验更多的字段呢？)，我们可以抽象出一个 point-free 风格的函数来完成上述操作：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">apply2</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> g<span class=\"token punctuation\">,</span> funtor1<span class=\"token punctuation\">,</span> functor2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">T</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ap</span><span class=\"token punctuation\">(</span>funtor1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ap</span><span class=\"token punctuation\">(</span>functor2<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">checkUserInfo</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">user</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">,</span> pw<span class=\"token punctuation\">,</span> phone <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> user\n    <span class=\"token keyword\">const</span> returnSuccess <span class=\"token operator\">=</span> <span class=\"token constant\">R</span><span class=\"token punctuation\">.</span><span class=\"token function\">curryN</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> success<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token function\">apply2</span><span class=\"token punctuation\">(</span>Right<span class=\"token punctuation\">,</span> returnSuccess<span class=\"token punctuation\">,</span> <span class=\"token function\">checkName</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">checkPW</span><span class=\"token punctuation\">(</span>pw<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">apply2</code> 函数的参数特别多，尤其是需要传递 <code class=\"language-text\">T</code> 这个不确定的容器，用来把普通函数 <code class=\"language-text\">g</code> 装进盒子里。</p>\n<blockquote>\n<p>把一个“值”(任意合法类型，当然包括函数)，装进容器中 (Box or Context) 中有一个统一的方法叫 <code class=\"language-text\">of</code> ，而这个过程被称为 <code class=\"language-text\">lift</code> ，意为提升：即把一个值提升到一个上下文中。</p>\n</blockquote>\n<p>再回头看看前面介绍的：<code class=\"language-text\">Box(addOne).ap(Box(2))</code> 和 <code class=\"language-text\">Box(2).map(addOne)</code> 从结果 (<code class=\"language-text\">Box(3)</code>) 上来看是一样。也就说执行 map 操作 (<code class=\"language-text\">map(addOne)</code>)等同于先执行 of (<code class=\"language-text\">Box(addOne)</code>)，然后执行 ap (<code class=\"language-text\">ap(Box(2))</code>)，用公式表达就是：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token constant\">F</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ap</span><span class=\"token punctuation\">(</span><span class=\"token constant\">F</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token constant\">F</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span></code></pre></div>\n<p>套用公式，我们可以修改简化 <code class=\"language-text\">apply2</code>  函数体中的 <code class=\"language-text\">T(g).ap(funtor1)</code> 为 <code class=\"language-text\">funtor1.map(g)</code> ，看下面的对比：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">apply2</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> g<span class=\"token punctuation\">,</span> funtor1<span class=\"token punctuation\">,</span> functor2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">T</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ap</span><span class=\"token punctuation\">(</span>funtor1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ap</span><span class=\"token punctuation\">(</span>functor2<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">liftA2</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">g<span class=\"token punctuation\">,</span> funtor1<span class=\"token punctuation\">,</span> functor2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> funtor1<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ap</span><span class=\"token punctuation\">(</span>functor2<span class=\"token punctuation\">)</span></code></pre></div>\n<p>看到了上面的关键点了吗？上面的 <code class=\"language-text\">liftA2</code> 函数中不再耦合于 “T” 这个特定类型的盒子，这样更加的通用灵活。</p>\n<p>按照上面的理论，可以改写 <code class=\"language-text\">checkUserInfo</code> 函数为：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">checkUserInfo</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">user</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">,</span> pw<span class=\"token punctuation\">,</span> phone <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> user\n    <span class=\"token keyword\">const</span> returnSuccess <span class=\"token operator\">=</span> <span class=\"token constant\">R</span><span class=\"token punctuation\">.</span><span class=\"token function\">curryN</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> success<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token function\">liftA2</span><span class=\"token punctuation\">(</span>returnSuccess<span class=\"token punctuation\">,</span> <span class=\"token function\">checkName</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">checkPW</span><span class=\"token punctuation\">(</span>pw<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>现在再假设一下我们新增了需要校验的第三个字段“手机号码”，那完全可以扩展 liftA2 函数为 liftA3，liftA4 等等:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">liftA3</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">g<span class=\"token punctuation\">,</span> funtor1<span class=\"token punctuation\">,</span> functor2<span class=\"token punctuation\">,</span> functor3</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> funtor1<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ap</span><span class=\"token punctuation\">(</span>functor2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ap</span><span class=\"token punctuation\">(</span>functor3<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">liftA4</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">g<span class=\"token punctuation\">,</span> funtor1<span class=\"token punctuation\">,</span> functor2<span class=\"token punctuation\">,</span> functor3<span class=\"token punctuation\">,</span> functor4</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> funtor1<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ap</span><span class=\"token punctuation\">(</span>functor2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ap</span><span class=\"token punctuation\">(</span>functor3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ap</span><span class=\"token punctuation\">(</span>functor4<span class=\"token punctuation\">)</span></code></pre></div>\n<blockquote>\n<p>刚开始可能会觉得 <code class=\"language-text\">liftA2-3-4</code> 看起来又丑又没必要；这种写法的意义在于：固定参数数量，一般会在函数式的 lib 中提供，不用自己手动去写这些代码。</p>\n</blockquote>\n<h3>Applicative Functor 和 Functor 的区别和联系</h3>\n<p>根据  <code class=\"language-text\">F(f).ap(F(x)) == F(x).map(f)</code>，我们可以得出一个结论，假如一个盒子 (Box) ，实现了 <code class=\"language-text\">ap</code> 方法，那么我们一定可以利用 <code class=\"language-text\">ap</code> 方法推导出一个 <code class=\"language-text\">map</code> 方法，如果拥有了 <code class=\"language-text\">map</code> 方法，那它就是一个 <code class=\"language-text\">Functor</code> ，所以我们也可以认为 <code class=\"language-text\">Applicative</code> 是 <code class=\"language-text\">Functor</code> 的拓展，比 <code class=\"language-text\">Functor</code> 更强大。</p>\n<p>那么强大在何处呢？<code class=\"language-text\">Functor</code> 只能映射一个接收单个参数的函数(e.g., <code class=\"language-text\">x =&gt; y</code>)，如果我们想把接收多个参数的函数(e.g., <code class=\"language-text\">x =&gt; y =&gt; z</code>)应用到多个值上，则是 <code class=\"language-text\">Applicative</code> 的舞台了，想想 <code class=\"language-text\">checkUserInfo</code> 的例子。</p>\n<blockquote>\n<p>毫无疑问，Applicative Funtor 可以 <code class=\"language-text\">apply</code> 多次（当然包括一次），那么如果函数只有一个参数的情况下，则可以认为 <code class=\"language-text\">map</code> 和 <code class=\"language-text\">apply</code> 是等效的，换句话说：<code class=\"language-text\">map</code> 相当于 <code class=\"language-text\">apply</code> 一次。</p>\n</blockquote>\n<p>上面是实际应用中的对比，从抽象的数学层面来对比：</p>\n<ul>\n<li>Functor: 应用一个函数到包裹的值：<code class=\"language-text\">Box(1).map(x =&gt; x+1)</code>.</li>\n<li>Applicative: 应用一个包裹的函数到包裹的值：<code class=\"language-text\">Box(x =&gt; x+1).ap(Box(1))</code>。</li>\n</ul>\n<p><img src=\"https://p1.music.126.net/qnIolKU9yLB9tH7onLbj7w==/109951164719087429.png\" alt=\"applicative vs functor\"></p>\n<h3>总结与计划</h3>\n<p>我们从纯函数与副作用的概念入手介绍了 <code class=\"language-text\">LazyBox</code> (惰性求值)的概念，从而引入了把函数这个“特殊的值”装进 Box 中，以及怎么 apply 这个“盒子中的函数”，然后介绍了函数柯里化与应用函子的关系(被装进盒子里的函数必须是柯里化的函数)；然后使用使用扩展后的 <code class=\"language-text\">Either</code> 来做表单校验，解耦合函数，最后介绍了使用 point-free 风格来编写链式调用。</p>\n<h4>计划</h4>\n<p>到目前为止，我们所讨论的问题都是同步的问题，但是在 Javascript 的世界中 90% 的代码都是异步，可以说异步才是 JavaScript 世界的主流，谁能更优雅的解决异步的问题，谁就是  JavaScript 中的大明星，从 <code class=\"language-text\">callback</code> ，到 <code class=\"language-text\">Promise</code> ，再到 <code class=\"language-text\">async await</code> ，那么在函数式编程中异步又该如何解决呢，下一章我们将会介绍一个重量级的概念 <code class=\"language-text\">Monad</code> 以及<code class=\"language-text\">异步函数的组合</code>。   </p>\n<p>参考资料与引用文章：   </p>\n<ul>\n<li><a href=\"https://medium.com/axiomzenteam/functor-applicative-and-why-8a08f1048d3d\">Functor, Applicative, and Why</a>   </li>\n<li><a href=\"https://stackoverflow.com/questions/46752031/what-is-my-applicative-functor-not-working-with-ramdas-ap\">Applicative and list</a>   </li>\n<li><a href=\"https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html\">Functors, Applicatives, And Monads In Pictures</a>     </li>\n<li><a href=\"https://codurance.com/2018/01/11/applicatives-validation/\">Applicative Functors and data validation</a>     </li>\n<li><a href=\"https://hackage.haskell.org/package/validation\">validation: A data-type like Either but with an accumulating Applicative</a>     </li>\n<li><a href=\"https://medium.com/beingprofessional/understanding-functor-and-monad-with-a-bag-of-peanuts-8fa702b3f69e\">Understanding Functor and Monad With a Bag of Peanuts</a>     </li>\n<li><a href=\"https://jrsinclair.com/articles/2018/how-to-deal-with-dirty-side-effects-in-your-pure-functional-javascript/\">How to deal with dirty side effects in your pure functional javascript</a>    </li>\n<li><a href=\"https://medium.com/free-code-camp/functional-programming-in-js-with-practical-examples-part-2-429d2e8ccc9e\">Functional Programming In JavaScript — With Practical Examples</a>     </li>\n<li>《JavaScript函数式编程》   </li>\n</ul>\n<blockquote>\n<p>本文发布自 <a href=\"https://github.com/x-orpheus\">网易云音乐大前端团队</a>，文章未经授权禁止任何形式的转载。我们常年招收前端、iOS、Android，如果你准备换工作，又恰好喜欢云音乐，那就加入我们 grp.music-fe(at)corp.netease.com！</p>\n</blockquote>","frontmatter":{"title":"函数式编程进阶：应用函子","date":"2020-11-06","description":"当你开始学习函数式编程的时候，你肯定听说过“纯函数”，“副作用”，“柯里化”等概念，本章将从这些基础概念入手开始，开始讲解把一个函数装进 “Box” 中的理念，然后引出“应用函子”的概念，并给出实际的应用案例。"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/javascript-functional-programming-functor/","previous":{"fields":{"slug":"/web-track/"},"frontmatter":{"title":"前端组件化埋点的实践"}},"next":{"fields":{"slug":"/rn-optimize/"},"frontmatter":{"title":"云音乐 React Native 优化实践之拆包与预热"}}}}}