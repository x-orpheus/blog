{"componentChunkName":"component---src-templates-blog-post-js","path":"/ssr-routing/","webpackCompilationHash":"3237468b0c27b1c362d5","result":{"data":{"site":{"siteMetadata":{"title":"云音乐大前端专栏","author":"云音乐大前端团队","siteUrl":"https://musicfe.dev"}},"markdownRemark":{"id":"60e842be-aeca-518a-b22c-063f10b0d085","excerpt":"本文作者 Bermudarat 头图来自 Level up your React architecture with MVVM, 作者 Danijel Vincijanovic 1. 前言 在开始正文前，先介绍几个概念（已经了解的朋友可以跳过）： Server Side Rendering（SSR…","html":"<p><img src=\"https://p1.music.126.net/YqeZUoezozlvQEcpfK1A6g==/109951164575937529.png\"></p>\n<blockquote>\n<p>本文作者 Bermudarat</p>\n</blockquote>\n<blockquote>\n<p><em>头图来自 <a href=\"https://cobe.tech/blog/post/level-up-your-react-architecture-with-mvvm\">Level up your React architecture with MVVM</a>, 作者 <a href=\"https://cobe.tech/blog/author/danijel-vincijanovic\">Danijel Vincijanovic</a></em></p>\n</blockquote>\n<h2>1. 前言</h2>\n<p>在开始正文前，先介绍几个概念（已经了解的朋友可以跳过）：</p>\n<p><strong>Server Side Rendering（SSR）</strong>：服务端渲染，简而言之就是后台语言通过模版引擎生成 HTML 。实现方式依赖于后台语言，例如 Python Flask 的 Jinja、Django 框架、Java 的 VM、Node.js 的 Jade 等。</p>\n<ul>\n<li>优点：SEO 友好、更短的白屏时间；</li>\n<li>缺点：每次都需请求完整页面、前后端开发职责不清；</li>\n</ul>\n<p><strong>Client Side Rendering（CSR）</strong>：客户端渲染，服务器只提供接口，路由以及渲染都丢给前端。</p>\n<ul>\n<li>优点：服务端计算压力小、可以实现页面的局部刷新：无需每次都请求完整页面、前后端分离；</li>\n<li>缺点：SEO 难度高、用户白屏时间长；</li>\n</ul>\n<p><strong>同构</strong>：前后端共用一套代码逻辑，所有渲染功能均由前端实现。在服务端输出含最基本的 HTML 文件；在客户端进一步渲染时，判断已有的 DOM 节点和即将渲染出的节点是否相同。如不同，重新渲染 DOM 节点，如相同，则只需绑定事件即可（这个过程，在 React 中称之为 <strong>注水</strong>）。同构是实现 SSR 的一种方式，侧重点在于代码复用。</p>\n<p><strong>静态路由</strong>：静态路由需要在页面渲染前声明好 URL 到页面的映射关系。如 Angular、Ember 中的路由，React Router v4 之前版本也采用此种路由。</p>\n<p><strong>动态路由</strong>：动态路由抛开了静态路由在渲染前定义映射关系的做法，在渲染过程中动态生成映射。React Router v4 版本提供了对动态路由的支持。</p>\n<p><strong>Code Splitting</strong>：也就是代码分割，是由诸如 Webpack，Rollup 和 Browserify（factor-bundle）这类打包器支持的一项技术，能够在打包文件时创建多个包并在运行时动态加载。</p>\n<p><a href=\"https://nextjs.org/\">Next.js</a>、 <a href=\"https://zh.nuxtjs.org/\">Nuxt.js</a> 是目前成熟的同构框架，前者基于 React，后者基于 Vue。有了这些框架，开发者可以方便地搭建一个同构应用：只对首屏同构直出，满足 SEO 需求，减少白屏时间；使用前端路由进行页面跳转，实现局部渲染。这些同构框架，已经在工程中得到了广泛应用。然而知其然也要知其所以然，对于一个功能完善的同构应用，需要解决以下几个方面的问题：</p>\n<ol>\n<li><strong>服务端</strong>：如何匹配 URL；页面数据预获取；响应字符串的组装与返回。</li>\n<li><strong>客户端</strong>：应用如何进行数据管理；如何使用服务端获取的数据进行渲染；客户端和服务端的数据获取方式不同，如何保持一致。</li>\n<li><strong>工程化</strong>：如何结合 Code Splitting，区分服务端和客户端，输出分块合理的 JS/CSS 文件；对于无法 SSR 的深层组件，如何延迟到客户端再初始化。</li>\n</ol>\n<p>上述问题的解决过程中，有很多坑会踩，本文主要讨论第一点。此外，提出一种解决方案，在服务端不使用中心化的路由配置，结合 Code Splitting ，通过一次预渲染，获取当前 URL 对应的模块名和数据获取方法。</p>\n<h2>2. 基于 React 的 SSR 实现</h2>\n<h3>2.1 通用思路</h3>\n<p>React 提供了 <a href=\"https://reactjs.org/docs/react-dom-server.html\">四个方法</a> 用来在服务端渲染 React 组件。其中，<code class=\"language-text\">renderToStaticMarkup</code>、<code class=\"language-text\">renderToStaticNodeStream</code> 不会在 React 内部创建额外的 DOM 属性，通常用于生成静态页面。同构中常用的是 <code class=\"language-text\">renderToString</code> 、 <code class=\"language-text\">renderToNodeStream</code> 这两个方法：前者将应用渲染成字符串；后者将应用渲染为 Stream 流，可以显著降低首字节响应时间（<a href=\"https://en.wikipedia.org/wiki/Time_to_first_byte\">TTFB</a>）。</p>\n<p>实现一个同构的 React 应用，需要以下几个步骤（<strong>下文均以字符串渲染为例</strong>）：</p>\n<ol>\n<li>获取匹配当前 URL 的路由，进而获取对应的数据获取方法；</li>\n<li>调用第一步获得的方法请求数据；</li>\n<li>结合上一步获取的数据（此处可以使用 Redux 等数据管理模块），调用 React 提供的 <code class=\"language-text\">renderToString</code> 方法，将应用渲染成字符串；</li>\n<li>将序列化的数据、上一步获得的字符串、客户端渲染所需的 JS/CSS 文件路径组装成 HTML 字符串，然后返回；</li>\n<li>浏览器获取响应后，进行解析。</li>\n</ol>\n<p>这是实现同构的通用思路，Next.js 框架也是这种思路。\n以上步骤的第一步，是获取匹配当前 URL 的路由。不同的路由对应不同的数据获取方法，这是后续步骤的前提。</p>\n<h3>2.2 使用 React Router</h3>\n<p>React Router v4 提供了 <a href=\"https://github.com/ReactTraining/react-router/tree/master/packages/react-router-config\">React Router Config</a> 实现中心化的静态路由配置，用于获取 React 应用的路由信息，方便在服务端渲染时获取数据：</p>\n<blockquote>\n<p>With the introduction of React Router v4, there is no longer a centralized route configuration. There are some use-cases where it is valuable to know about all the app's potential routes such as:</p>\n<ul>\n<li><strong>Loading data on the server or in the lifecycle before rendering the next screen</strong></li>\n<li>Linking to routes by name</li>\n<li>Static analysis</li>\n</ul>\n</blockquote>\n<p>React Router Config 提供了 <code class=\"language-text\">matchRoutes</code> 方法实现路由匹配。如何使用，在 <a href=\"https://github.com/ReactTraining/react-router/tree/master/packages/react-router-config\">文档</a> 中有详细的说明:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// routes 为中心化的路由配置文件</span>\n<span class=\"token keyword\">const</span> routes <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span>\n    path<span class=\"token punctuation\">:</span> <span class=\"token string\">\"/\"</span><span class=\"token punctuation\">,</span>\n    component<span class=\"token punctuation\">:</span> Root<span class=\"token punctuation\">,</span>\n    <span class=\"token function-variable function\">loadData</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">getSomeData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">loadBranchData</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">location</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> branch <span class=\"token operator\">=</span> <span class=\"token function\">matchRoutes</span><span class=\"token punctuation\">(</span>routes<span class=\"token punctuation\">,</span> location<span class=\"token punctuation\">.</span>pathname<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 调用 route 上定义的数据获取方法</span>\n    <span class=\"token keyword\">const</span> promises <span class=\"token operator\">=</span> branch<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span>route<span class=\"token punctuation\">,</span> match<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> route<span class=\"token punctuation\">.</span>loadData <span class=\"token operator\">?</span> route<span class=\"token punctuation\">.</span><span class=\"token function\">loadData</span><span class=\"token punctuation\">(</span>match<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span>promises<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 预获取数据，并在 HTML 文件中写入数据</span>\n<span class=\"token function\">loadBranchData</span><span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">.</span><span class=\"token constant\">URL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">data</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">putTheDataSomewhereTheClientCanFindIt</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">loadData</code> 方法除了作为路由的属性外，也可以在 <code class=\"language-text\">Root</code> 的静态方法中定义。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Root 组件</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Root</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nRoot<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">loadData</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">getSomeData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 路由配置</span>\n<span class=\"token keyword\">const</span> routes <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span>\n    path<span class=\"token punctuation\">:</span> <span class=\"token string\">\"/\"</span><span class=\"token punctuation\">,</span>\n    component<span class=\"token punctuation\">:</span> Root\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 页面匹配</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">loadBranchData</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">location</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// routes 为中心化的路由配置文件</span>\n    <span class=\"token keyword\">const</span> branch <span class=\"token operator\">=</span> <span class=\"token function\">matchRoutes</span><span class=\"token punctuation\">(</span>routes<span class=\"token punctuation\">,</span> location<span class=\"token punctuation\">.</span>pathname<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 调用 component 上的静态数据获取方法</span>\n    <span class=\"token keyword\">const</span> promises <span class=\"token operator\">=</span> branch<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span>route<span class=\"token punctuation\">,</span> match<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> route<span class=\"token punctuation\">.</span>component<span class=\"token punctuation\">.</span>loadData <span class=\"token operator\">?</span> route<span class=\"token punctuation\">.</span>component<span class=\"token punctuation\">.</span><span class=\"token function\">loadData</span><span class=\"token punctuation\">(</span>match<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span>promises<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>接下就可以使用预获取的数据进行渲染。</p>\n<p>HTML 字符串中需要包含客户端渲染所需的 JS/CSS 标签。对于没有 Code Splitting 的应用，很容易定位这些资源文件。然而对于一个复杂的单页应用，不进行 Code Splitting 会导致 JS 文件体积过大，增加了传输时间和浏览器解析时间，从而导致页面性能下降。在 SSR 时，如何筛选出当前 URL 对应的 JS/CSS 文件，是接下来要解决的问题。</p>\n<h3>2.3 Code Splitting 与 SSR</h3>\n<p><img src=\"https://p1.music.126.net/ZAXt_475DpwYP72jrLOBxA==/109951164575357202.png\"></p>\n<p>Webpack 根据 ECMAScript 提案实现了用于动态加载模块的 <code class=\"language-text\">import</code> 方法。React v16.6 版本提供了 <code class=\"language-text\">React.lazy</code> 和 <code class=\"language-text\">Suspend</code>，用于动态加载组件。然而 <code class=\"language-text\">React.lazy</code> 和 <code class=\"language-text\">Suspend</code> 并不适用于 SSR，我们仍需要引入第三方的动态加载库：</p>\n<blockquote>\n<p>React.lazy and Suspense are not yet available for server-side rendering. If you want to do code-splitting in a server rendered app, we recommend Loadable Components. It has a nice guide for bundle splitting with server-side rendering.</p>\n</blockquote>\n<p>目前已有很多成熟的第三方的动态加载库： 早期的 React 官方文档中推荐的 <a href=\"https://github.com/jamiebuilds/react-loadable\">react-loadable</a>，最新推荐的 <a href=\"https://github.com/gregberge/loadable-components#readme\">@loadable/component</a>，以及 <a href=\"https://github.com/faceyspacey/react-universal-component\">react-universal-component</a> 等等，他们提出这样一种解决方案：</p>\n<ol>\n<li>在 Webpack 打包时，输出每一个动态加载组件对应的 JS/CSS 配置。Webpack 提供了输出包含所有模块信息的 json 文件的 <a href=\"https://webpack.js.org/api/stats/\">CLI 命令</a>:\n<code class=\"language-text\">webpack --profile --json &gt; compilation-stats.json</code>。除了命令行的方式，配置文件也可以通过 <a href=\"https://github.com/FormidableLabs/webpack-stats-plugin#readme\">webpack-stats-plugin</a> 插件生成。此外，一些第三方动态加载库也提供了插件生成这些配置（例如 <a href=\"https://github.com/jamiebuilds/react-loadable\">react-loadable</a> 提供的 <a href=\"https://github.com/jamiebuilds/react-loadable#webpack-plugin\"><code class=\"language-text\">ReactLoadablePlugin</code></a>）；</li>\n<li>渲染时，通过 <a href=\"https://reactjs.org/docs/context.html\">React Context</a> 获取此次渲染中所有动态加载的组件的模块名 <code class=\"language-text\">chunkNames</code>；</li>\n<li>从第一步产生的配置文件中，提取 <code class=\"language-text\">chunkNames</code> 对应的分块代码信息，并组装成 JS/CSS 标签。</li>\n</ol>\n<p>以 <a href=\"https://github.com/faceyspacey/react-universal-component\">react-universal-component</a> 为例，代码实现如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span>ReportChunks<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react-universal-component'</span>\n<span class=\"token keyword\">import</span> flushChunks <span class=\"token keyword\">from</span> <span class=\"token string\">'webpack-flush-chunks'</span>\n<span class=\"token keyword\">import</span> ReactDOM <span class=\"token keyword\">from</span> <span class=\"token string\">'react-dom/server'</span>\n<span class=\"token comment\">// webpackStats 中包含了应用中所有模块的数据信息，可以通过 webpack 打包获得</span>\n<span class=\"token keyword\">import</span> webpackStats <span class=\"token keyword\">from</span> <span class=\"token string\">'./dist/webpackstats.json'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">renderToHtml</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 保存匹配当前 URL 的组件 chunk</span>\n    <span class=\"token keyword\">let</span> chunkNames <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> appHtml <span class=\"token operator\">=</span> ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">renderToString</span><span class=\"token punctuation\">(</span>\n        <span class=\"token comment\">// ReportChunks 通过 React Context 将 report 方法传递至每个动态加载组件上。组件在加载时，执行 report 方法，从而将组件的模块名传递至外部。</span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ReportChunks</span></span> <span class=\"token attr-name\">report</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token parameter\">chunkName</span> <span class=\"token operator\">=></span> chunkNames<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>chunkName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n            </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">App</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">ReportChunks</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 提取 webpacStats 中 chunkNames 的信息，并组装为标签；</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>scripts<span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">flushChunks</span><span class=\"token punctuation\">(</span>webpackStats<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n        chunkNames<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 后续省略</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>综上，使用 React Router 进行服务端渲染，需要执行以下步骤：</p>\n<ol>\n<li>Webpack 打包时，输出包含所有动态加载组件对应 JS/CSS 信息的配置文件；</li>\n<li>使用 React Router 的中心化配置文件，获取当前 URL 对应组件的静态数据获取方法；</li>\n<li>使用动态加载库，结合第一步的配置文件，在应用渲染过程中，获取代码分块信息；</li>\n<li>HTML 字符串组装。</li>\n</ol>\n<p>上述过程，流程如下：\n<img src=\"https://p1.music.126.net/zF63lSccBv6C4JvqwpVIgQ==/109951164575350461.png\"></p>\n<h2>3 动态路由匹配</h2>\n<h3>3.1 静态路由 Vs 动态路由</h3>\n<p>上述讨论中，在进行 URL 匹配时，我们使用了中心化的静态路由配置。React Router v4 版本的最大改进，就是提出了动态路由。<code class=\"language-text\">Route</code> 作为一种真正的 React 组件，与 UI 展示紧密结合，而不是之前版本中的伪组件。有了动态路由组件，我们不再需要中心化的路由配置。</p>\n<p>与静态路由相比，动态路由在设计上有很多 <a href=\"https://www.gistia.com/comprehensive-guide-to-react-router-4/\">改进之处</a>。此外，动态路由在深层路由的书写上，也比中心化的静态路由要方便。\n使用 React Router Config 进行中心化的静态路由配置需要提供如下的路由配置文件：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> routes <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span>\n        component<span class=\"token punctuation\">:</span> Root<span class=\"token punctuation\">,</span>\n        routes<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n            <span class=\"token punctuation\">{</span>\n                path<span class=\"token punctuation\">:</span> <span class=\"token string\">\"/\"</span><span class=\"token punctuation\">,</span>\n                exact<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n                component<span class=\"token punctuation\">:</span> Home\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">{</span>\n                path<span class=\"token punctuation\">:</span> <span class=\"token string\">\"/child/:id\"</span><span class=\"token punctuation\">,</span>\n                component<span class=\"token punctuation\">:</span> Child<span class=\"token punctuation\">,</span>\n                routes<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n                    <span class=\"token punctuation\">{</span>\n                        path<span class=\"token punctuation\">:</span> <span class=\"token string\">\"/child/:id/grand-child\"</span><span class=\"token punctuation\">,</span>\n                        component<span class=\"token punctuation\">:</span> GrandChild\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">]</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>采用动态路由，则完全不需要上述配置文件。 以 <code class=\"language-text\">Child</code> 组件为例， 可以在组件中配置子路由。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Child</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 使用 match.path，可以避免前置路径的重复书写</span>\n    <span class=\"token keyword\">let</span> match <span class=\"token operator\">=</span> <span class=\"token function\">useRouteMatch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n            </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Child</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n            </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Route</span></span> <span class=\"token attr-name\">path</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>match<span class=\"token punctuation\">.</span>path<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">/grand-child</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>但是如果使用动态路由的话，该如何与当前 URL 匹配呢？</p>\n<h3>3.2. 动态加载库的改进</h3>\n<p>前面介绍了，<a href=\"https://github.com/faceyspacey/react-universal-component\">react-universal-component</a> 等动态加载组件， 可以通过一次渲染，获取对应当前 URL 的模块名。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">    <span class=\"token keyword\">let</span> chunkNames <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> appHtml <span class=\"token operator\">=</span> ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">renderToString</span><span class=\"token punctuation\">(</span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ReportChunks</span></span> <span class=\"token attr-name\">report</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token parameter\">chunkName</span> <span class=\"token operator\">=></span> chunkNames<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>chunkName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n            </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">App</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">ReportChunks</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>我们是否可以使用类似的方式，通过一次渲染，将定义在组件上的数据获取方法传递至外部呢？比如下面的书写方式：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">    <span class=\"token keyword\">let</span> chunkNames <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> loadDataMethods <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> appHtml <span class=\"token operator\">=</span> ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">renderToString</span><span class=\"token punctuation\">(</span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ReportChunks</span></span> <span class=\"token attr-name\">report</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">chunkName<span class=\"token punctuation\">,</span> loadData</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n            chunkNames<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>chunkName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            loadDataMethods<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>loadData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n            </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">App</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">ReportChunks</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><a href=\"https://github.com/faceyspacey/react-universal-component\">react-universal-component</a> 中， <code class=\"language-text\">ReportChunks</code> 组件使用 <a href=\"https://reactjs.org/docs/context.html\">React Context</a> 将 <code class=\"language-text\">report</code> 方法传递至每个动态加载组件上。组件在加载时，执行 <code class=\"language-text\">report</code> 方法，将组件的模块名传递至外部。</p>\n<p>因此，我们只需要修改动态加载方法，使其在执行 <code class=\"language-text\">report</code> 方法时，同时将模块名 <code class=\"language-text\">chunkName</code> 和组件上的静态方法返回即可：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// AsyncComponent 提供在服务端同步加载组件的功能</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">AsyncComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>report<span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// syncModule 为内置函数，不对用户暴露，主要功能是使用 webpack 提供的 require.resolveWeak 方法实现模块的同步加载；</span>\n        <span class=\"token keyword\">const</span> comp <span class=\"token operator\">=</span> <span class=\"token function\">syncModule</span><span class=\"token punctuation\">(</span>resolveWeak<span class=\"token punctuation\">,</span> load<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>report <span class=\"token operator\">&amp;&amp;</span> comp<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">const</span> exportStatic <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// 将 comp 的静态方法复制至 exportStatic</span>\n            <span class=\"token function\">hoistNonReactStatics</span><span class=\"token punctuation\">(</span>exportStatic<span class=\"token punctuation\">,</span> comp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            exportStatic<span class=\"token punctuation\">.</span>chunkName <span class=\"token operator\">=</span> chunkName<span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// 将 chunkName 和静态方法传递给外部</span>\n            <span class=\"token function\">report</span><span class=\"token punctuation\">(</span>exportStatic<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>完整的实现可以参考 <a href=\"https://github.com/caoren/react-asyncmodule/blob/master/packages/react-asyncmodule/src/index.js#L80-L90\">react-asyncmodule</a>。<a href=\"https://github.com/caoren/react-asyncmodule/blob/master/packages/react-asyncmodule/src/index.js#L80-L90\">react-asyncmodule</a> 提供了 <code class=\"language-text\">AsyncChunk</code> 组件，与 <a href=\"https://github.com/faceyspacey/react-universal-component\">react-universal-component</a> 提供的 <code class=\"language-text\">ReportChunks</code> 组件相似，作用是将 <code class=\"language-text\">report</code> 方法传递至每个动态加载组件上。使用方法如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">    <span class=\"token keyword\">let</span> modules <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">saveModule</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">m</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// m 中包含 chunkName 和静态数据获取方法；</span>\n        <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> chunkName <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> m<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 过滤重复的 chunkName</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>modules<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span> <span class=\"token operator\">=></span> e<span class=\"token punctuation\">.</span>chunkName <span class=\"token operator\">===</span> chunkName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        modules<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> appHtml <span class=\"token operator\">=</span> ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">renderToString</span><span class=\"token punctuation\">(</span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">AsyncChunk</span></span> <span class=\"token attr-name\">report</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>saveModule<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n            </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">App</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">AsyncChunk</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>完整流程如下：\n<img src=\"https://p1.music.126.net/9yrSb91rOcEZTFljsqFsLA==/109951164575352405.png\"></p>\n<h2>4. 局限性和解决办法</h2>\n<p>通过一次预渲染，获取对应当前 URL 的模块名和数据获取方法，适用于大部分动态路由的场景。但是如果动态加载组件本身是否渲染依赖于数据，那么在预渲染时，这个组件的模块名和静态方法不能正常获取。如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> PageA <span class=\"token operator\">=</span> <span class=\"token function\">AsyncComponent</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./PageA'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">BasicExample</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>canRender<span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Router</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n                </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Route</span></span> <span class=\"token attr-name\">exact</span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n                </span><span class=\"token punctuation\">{</span>\n                    canRender <span class=\"token operator\">?</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">PageA</span></span> <span class=\"token punctuation\">/></span></span> <span class=\"token punctuation\">:</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Render Nothing!</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n                <span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n                </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Route</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n            </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Router</span></span><span class=\"token punctuation\">></span></span>\n        <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nBasicExample<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">getInitialProps</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 此处获取 canRender，用于确定 PageA 组件是否渲染</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>预渲染时 <code class=\"language-text\">canRender</code> 为 <code class=\"language-text\">undefined</code>, 不会渲染 <code class=\"language-text\">PageA</code> ，所以也不能获取到 <code class=\"language-text\">PageA</code> 对应的模块名和静态方法。正式渲染时，服务端渲染出的页面中会缺少 <code class=\"language-text\">PageA</code> 中的数据信息。为了解决这个问题，业务代码需要在 <code class=\"language-text\">PageA</code> 的 <code class=\"language-text\">componentDidMount</code> 生命周期中，进行数据的获取，以正确展示页面。</p>\n<p>此外，预渲染可以使用 <code class=\"language-text\">renderToStaticMarkup</code> 方法，相比 <code class=\"language-text\">renderToString</code>，<code class=\"language-text\">renderToStaticMarkup</code> 不会生成额外的 React 属性，因此减少了 HTML 字符串的大小。但是预渲染本身增加了服务端的计算压力，所以可以考虑缓存预渲染结果，实现思路如下：</p>\n<ol>\n<li>定义缓存 <code class=\"language-text\">moduleCache</code>；</li>\n<li>对于每次请求，使用 React Router 的 <a href=\"https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/matchPath.js\"><code class=\"language-text\">matchPath</code></a> 方法，在 <code class=\"language-text\">moduleCache</code> 中查找是否有此 path string 模式（例如 <code class=\"language-text\">/user/:name</code>）的缓存，如果有，则使用缓存的方法进行数据获取；</li>\n<li>如果没有，则进行预渲染，并将获取的模块信息存入缓存。</li>\n</ol>\n<p>使用这种方法，对于不同的 path string 模式，只需在第一次请求时进行一次预渲染。之后再次请求，使用缓存数据即可。</p>\n<h2>5. 参考资料</h2>\n<p>均以外链形式列出</p>\n<blockquote>\n<p>本文发布自 <a href=\"https://github.com/x-orpheus\">网易云音乐前端团队</a>，文章未经授权禁止任何形式的转载。我们一直在招人，如果你恰好准备换工作，又恰好喜欢云音乐，那就 <a href=\"mailto:grp.music-fe@corp.netease.com\">加入我们</a>！</p>\n</blockquote>","frontmatter":{"title":"支持动态路由的 React Server Side Rendering 实现","date":"2020-02-28","description":"服务端渲染有很多坑会踩，针对路由本文提出一种解决方案，在服务端不使用中心化的路由配置，结合 Code Splitting ，通过一次预渲染，获取当前 URL 对应的模块名和数据获取方法。"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/ssr-routing/","previous":{"fields":{"slug":"/dsl/"},"frontmatter":{"title":"前端 DSL 实践指南（上）—— 内部 DSL"}},"next":{"fields":{"slug":"/threejs/"},"frontmatter":{"title":"Three.js 动效方案"}}}}}