{"componentChunkName":"component---src-templates-blog-post-js","path":"/android-privacy-2/","webpackCompilationHash":"a328ffc1161c667df4f7","result":{"data":{"site":{"siteMetadata":{"title":"云音乐大前端专栏","author":"云音乐大前端团队","siteUrl":"https://musicfe.dev"}},"markdownRemark":{"id":"677abfbd-400a-5dea-ae4d-887719e3bfb4","excerpt":"本文作者：烧麦 前言 笔者之前在云音乐大前端公众号分享了 Android 隐私合规静态检查的一部分实现。\nAndroid隐私合规静态检查 上一篇文章通过反编译 APP 的方式，扫描了 APP 内对隐私方法调用的检查。但存在一些问题： 无法检查到 so…","html":"<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/12195272929/34d3/7924/ef23/a019fe44e0bf085fe985ebaa73331689.jpg\"></p>\n<blockquote>\n<p>本文作者：<a href=\"http://github.com/shaomaicheng\">烧麦</a></p>\n</blockquote>\n<h1>前言</h1>\n<p>笔者之前在云音乐大前端公众号分享了 Android 隐私合规静态检查的一部分实现。\n<a href=\"https://mp.weixin.qq.com/s/U06HZb1P5Z2bK_ibtJk9KA\">Android隐私合规静态检查</a></p>\n<p>上一篇文章通过反编译 APP 的方式，扫描了 APP 内对隐私方法调用的检查。但存在一些问题：</p>\n<ul>\n<li>无法检查到 so 文件里是否可能存在隐私方法的调用。</li>\n<li>当我们全量扫描出某个地方存在隐私方法调用的时候，我们不知道它实际的调用的入口究竟在哪里。</li>\n</ul>\n<h1>so 文件里的调用</h1>\n<p>有时候我们有一些隐私方法是通过 JNI 反射执行 Java 层代码调用的，无法通过扫描 Java 层文件找到。所以需要针对 so 文件做一个特殊处理。</p>\n<p>我们来梳理一下我们的需求：对于 APP 业务方，一般来说只需要知道某些隐私方法有没有通过 so 调用。在哪个 so 里可能会存在调用。剩下的，我们交给 so 的开发者去排查就行了。</p>\n<p>需求明确了，那我们怎么知道 so 文件里是否调用了某个方法呢？在 Java 中，如果通过反射调用方法，类名+方法名的字符串肯定是作为字符串常量存在 class 文件的常量池内。那么 so 里是否会有类似的存储方式呢？</p>\n<p>答案是肯定的，linux C 程序的字符串可能存在于以下 2 个区域：</p>\n<ul>\n<li>.text  代码段，通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读,某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</li>\n<li>.rodata 该段也叫常量区，用于存放常量数据，ro 就是 ReadOnly 的意思。存放 C 中的字符串和 #define 定义的常量.</li>\n</ul>\n<p>我们可以通过 linux 的 <code class=\"language-text\">strings</code> 命令，来获取 so 文件里面使用到的字符串：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">strings xx.so</code></pre></div>\n<p>我们检查 apk 文件里每个 so 文件的字符串，如果能匹配上配置的隐私方法名，那么就把当前的 so 标记为可疑的调用。检查的流程如下图：</p>\n<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/12189102816/853e/793c/a302/1629aee4571ef134acbe5ba17213c030.png\"></p>\n<p>检查输出结果参考下面的 demo 示图：</p>\n<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/12189121445/cee2/5bcb/bbe4/bce38ada3c0ae49e8f53250ad0b7bf38.png\"></p>\n<h1>方法调用链分析</h1>\n<p>很多时候我们不知道是哪里调用了某个 Android API， 一般只能通过运行时去处理一下，例如 hook 这个方法替换它的实现。但是运行时检查覆盖不了所有的场景。所以静态检查 apk 的方法调用链是很必要的。至少我们可以看到某个敏感方法的调用源头是哪个类，从而进行溯源和归因。</p>\n<p>笔者在上一篇分享的技术方案基础之上，进一步分析了方法调用链。上篇文章我们说到了通过反编译 apk，我们能转换生成相关的 smali 文件，smali 文件里会存在相关的方法调用信息。我们可以通过这些方法信息将整个 app 的方法调用关系组织起来。</p>\n<h3>方法收集</h3>\n<p>在 smali 文件的开头，会标记当前类的相关信息:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">.class public final Lokhttp3/OkHttp;\n.super Ljava/lang/Object;</code></pre></div>\n<p>我们会获取到当前一个类的修饰符和完整的类型描述符。</p>\n<p>smali 里的 <code class=\"language-text\">.method</code> 指令则描述了当前 class 里有哪些方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">.method constructor &lt;init&gt;(Lokhttp3/Call$Factory;Lokhttp3/HttpUrl;Ljava/util/List;Ljava/util/List;Ljava/util/concurrent/Executor;Z)V\n\n.method private validateServiceInterface(Ljava/lang/Class;)V\n\n.method public baseUrl()Lokhttp3/HttpUrl;</code></pre></div>\n<p>这里以 <code class=\"language-text\">Retrofit</code> 为例，我们可以看到 <code class=\"language-text\">Retrofit.smali</code> 里面的方法描述：</p>\n<ul>\n<li>构造方法，传入的参数为 Factory、HttpUrl、List、List、Executor 和 boolean</li>\n<li>私有方法 validateServiceInterface，参数为 Class，返回 void</li>\n<li>公开方法 baseUrl，无参数，返回 HttpUrl</li>\n</ul>\n<p>通过上述这些信息，我们可以收集到一个 APP 内，所有的方法。我们需要为每个方法建立自己的可识别性，我们通过下面这些字段来进行判断：</p>\n<ul>\n<li>方法定义所在的类，需要是完整的包名+类名</li>\n<li>\n<p>一个方法签名内需要的字段，包括：</p>\n<ul>\n<li>方法名</li>\n<li>传入的参数</li>\n</ul>\n</li>\n</ul>\n<p>在 smali 中，方法的描述符是使用的 jvm 的描述符，我们需要解析描述符里的信息，来保存我们的每个字段以备输出显示。\n方法的描述符规则会把符号和类型对应起来，基本类型的关系为：</p>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>V</td>\n<td>void</td>\n</tr>\n<tr>\n<td>Z</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td>S</td>\n<td>short</td>\n</tr>\n<tr>\n<td>C</td>\n<td>char</td>\n</tr>\n<tr>\n<td>I</td>\n<td>int</td>\n</tr>\n<tr>\n<td>J</td>\n<td>long</td>\n</tr>\n<tr>\n<td>F</td>\n<td>float</td>\n</tr>\n<tr>\n<td>D</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p>对象则表示为完整的包名和类名，<code class=\"language-text\">L</code> 开头，使用文件描述符间隔，使用分号结尾，例如 Strig:</p>\n<p>LJava/lang/String;</p>\n<h3>方法关系建立</h3>\n<p>收集到了所有的方法，我们建立调用链就还需要知道，方法调用了谁，以及方法被谁调用了。\n在 smali 中，我们可以通过 <code class=\"language-text\">invoke-</code> 指令找到某个方法内调用了哪些其他方法：</p>\n<p><code class=\"language-text\">invoke-</code> 包括 </p>\n<ul>\n<li><code class=\"language-text\">invoke-direct</code> 直接调用某个方法</li>\n<li><code class=\"language-text\">invoke-static</code> 调用某个 static 方法</li>\n<li><code class=\"language-text\">invoke-virtual</code> 调用某个虚方法</li>\n<li><code class=\"language-text\">invoke-super</code> 直接调用父类的虚方法</li>\n<li><code class=\"language-text\">invoke-interface</code> 调用某个接口的方法</li>\n</ul>\n<p>除了 <code class=\"language-text\">invoke-interface</code> 需要在运行时确认调用对象，其他几个是可以通过 <code class=\"language-text\">invoke-</code> 后面的描述部分知道当前方法调用了哪些方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">invoke-virtual {v2, p2, v1}, Ljava/util/HashMap;-&gt;put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</code></pre></div>\n<p><code class=\"language-text\">invoke-</code> 后半段指令描述了具体调用的类名和方法，使用 -> 分隔开。解析这部分指令，我们可以获取到被调用方法的完整信息。</p>\n<p>我们可以通过对整个 app 内反编译出的 smali 文件的调用关系进行一个收集，收集过程中，每个方法都会被存储下来，每个方法除了自己的方法信息，还包括被调用的列表：</p>\n<ul>\n<li>calleds: 调用了自己的方法列表</li>\n</ul>\n<p>当某个方法调用被扫描到的时候，我们会把这个方法添加到当前调用者的 callers 里面，同时也把调用者添加到自己的 calleds 里面去。最终方法关系就建立成如下图所示：</p>\n<p><img src=\"https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/12195016576/5dd4/9fff/b805/ef339fadb0c14c9e6b59afa519dc519f.png\"></p>\n<p><img src=\"https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/12194987432/e2a4/1f75/95d9/37550b3ade462e27ef8480e049687e06.png\"></p>\n<p>我们最终建立了一颗多叉树的图结构，这张图里，我们可以把我们需要检查调用链的隐私方法看做是树的叶子节点。</p>\n<p>当然，我们也可以再新增一个 callers 数组，来表示每个方法调用的方法列表，这样我们还可以建立一个节点点存在双向绑定关系的树结构：</p>\n<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/12194773650/93be/9503/d86a/2a56e28c95c13c946c49c675af5861ad.png\"></p>\n<p>在双向绑定的树结构中，我们既可以根据某个方法去分析出这个方法的调用链。也可以从顶层开始，分析某些入口所有可能存在的调用链。\n例如，当我们怀疑某些页面存在不合规的调用时，我们可以把这些 Activity 的类找到，从上往下去寻找是否调用了隐私方法。</p>\n<h3>调用链遍历</h3>\n<p>方法调用的关系建立完毕后，我们需要遍历出所有的调用链并输出给使用方。这里就比较简单了，我们可以使用深度优先遍历来寻找我们的所有可能的路径：</p>\n<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/12195054954/de75/1b0d/b52d/cad43ffcd6303c1aaab627613d1d79b1.png\"></p>\n<p>这里存在一种特殊情况，在递归的时候，有可能会出现 A 被 B 调用， B 又被 A 调用的情况，反映到当前的数据结构就是图结构形成了环。所以我们需要针对是否存在环进行判断。</p>\n<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/12195111303/e653/8069/067f/cdcc8eba2b574664831ee75e8b2730ea.png\"></p>\n<p>当我们判断到当前调用链上存在重复节点的时候，就可以认定为存在环。这时候可以直接结束这条链上的递归，实际上也并不会影响我们事后分析这条调用链的合规性。</p>\n<p>这部分逻辑可以用伪代码来表示：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">fun traversal(method) {\n    val paths = []\n    dfs(method, [], paths)\n}\n\nfun dfs(method, path, temp) {\n    if (method.calleds.isNotEmpty) {\n        for (called in method.calleds) {\n            if (path.contains(called)) {\n                temp.add(path)\n                continue\n            } else {\n                newPath = []\n                newPath.addAll(path)\n                newPath.add(0, method)\n                dfs(called.method, newPath, temp)\n            }\n        }\n    } else {\n        path.add(0, method)\n        temp.add(path)\n    }\n}</code></pre></div>\n<p>调用链分析最后的效果如下图：</p>\n<p><img src=\"https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/12194277462/efac/7a39/157c/b97aac5685c3861fd03de6c69b34af91.png\"></p>\n<h1>总结</h1>\n<p>到这里静态检查 Android 隐私合规调用就分享的差不多了，但是隐私合规相关的工作能做的还有很多。\n静态的检查也只是辅助我们定位和检查可能存在的问题。我们仍然可以探索很多运行时的监测方案，两者互补之后的效果也会更好。</p>\n<blockquote>\n<p>本文发布自 <a href=\"https://github.com/x-orpheus\">网易云音乐大前端团队</a>，文章未经授权禁止任何形式的转载。我们常年招收前端、iOS、Android，如果你准备换工作，又恰好喜欢云音乐，那就加入我们 grp.music-fe(at)corp.netease.com！</p>\n</blockquote>","frontmatter":{"title":"Android隐私合规静态检查（二）","date":"2021-12-27","description":"之前分享了一篇关于 Android 隐私静态合规检查的文章，今天我们继续分享一下如何针对 so 调用、查找隐私方法调用入口等场景进行静态检查工作。"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/android-privacy-2/","previous":{"fields":{"slug":"/look-map/"},"frontmatter":{"title":"LOOK直播活动地图生成器方案"}},"next":null}}}