{"componentChunkName":"component---src-templates-blog-post-js","path":"/android-agp/","webpackCompilationHash":"93dc93a4d7b7440fdbd5","result":{"data":{"site":{"siteMetadata":{"title":"云音乐大前端专栏","author":"云音乐大前端团队","siteUrl":"https://musicfe.dev"}},"markdownRemark":{"id":"f53c862d-d029-55ec-90dd-3df32c052870","excerpt":"header.png 本文作者：郑超 背景 最近团队升级静态代码检测能力，依赖的相关编译检测能力需要用到较新的agp，而且目前云音乐agp版本用的是 3.5.0，对比现在 4.2.0 有较大差距，所以我们集中对 agp 进行了一次升级。在升级前通过官方文档，发现在 agp3.6.0 和 4.1.0 版本分别对 R…","html":"<p><img src=\"https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/9643935463/2a84/cdc0/8d0c/98671353a55992e35e7249737e26dc6a.jpg\" alt=\"header.png\"></p>\n<blockquote>\n<p>本文作者：<a href=\"https://www.jianshu.com/u/086364200d62\">郑超</a></p>\n</blockquote>\n<h2>背景</h2>\n<p>最近团队升级静态代码检测能力，依赖的相关编译检测能力需要用到较新的agp，而且目前云音乐agp版本用的是 3.5.0，对比现在 4.2.0 有较大差距，所以我们集中对 agp 进行了一次升级。在升级前通过官方文档，发现在 agp3.6.0 和 4.1.0 版本分别对 R 文件的处理方式进行了相应的升级,具体升级如下。</p>\n<h2>agp 3.6.0 变更</h2>\n<p><strong>Simplified R class generation</strong></p>\n<p>The Android Gradle plugin simplifies the compile classpath by generating only one R class for each library module in your project and sharing those R classes with other module dependencies. This optimization should result in faster builds, but it requires that you keep the following in mind:</p>\n<ul>\n<li>Because the compiler shares R classes with upstream module dependencies, it’s important that each module in your project uses a unique package name.</li>\n<li>The visibility of a library's R class to other project dependencies is determined by the configuration used to include the library as a dependency. For example, if Library A includes Library B as an 'api' dependency, Library A and other libraries that depend on Library A have access to Library B's R class. However, other libraries might not have access to Library B's R class If Library A uses the implementation dependency configuration. To learn more, read about dependency configurations.</li>\n</ul>\n<p>从字面意思理解 <code class=\"language-text\">agp3.6.0</code> 简化了 R 的生成过程，每一个 module 直接生成 <code class=\"language-text\">R.class</code> (在 3.6.0 之前 R.class 生成的过程是为每个 module 先生成  R.java -> 再通过 javac 生成 R.class ,现在是省去了生成 R.java 和通过 javac 生成 R.class)</p>\n<p>现在我们来验证一下这个结果，建一个工程，工程中会建立 android library module。分别用 agp3.5.0 和 agp3.6.0 编译，然后看构建产物。</p>\n<h4>agp 3.5.0 构建产物如下：</h4>\n<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/9540496829/89a8/534c/13c4/e4fc60e69bde4b92ec45245c1a1e5bd9.jpg\" alt=\"image\"></p>\n<h4>agp 3.6.0 构建产物如下：</h4>\n<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/9540496693/45e9/8e18/9bcd/463aa2248681a8815b185fc4a4b6b7af.jpg\" alt=\"image\"></p>\n<p>从构建产物上来看也验证了这个结论，agp 3.5.0 到 3.6.0 通过减少 R 生成的中间过程，来提升 R 的生成效率（先生成 R.java 再通过 javac 生成 R.class 变为直接生成 R.class）；</p>\n<h2>agp 4.1.0升级如下：</h2>\n<p><strong>App size significantly reduced for apps using code shrinking</strong></p>\n<p>Starting with this release, fields from R classes are no longer kept by default, which may result in significant APK size savings for apps that enable code shrinking. This should not result in a behavior change unless you are accessing R classes by reflection, in which case it is necessary to add keep rules for those R classes.</p>\n<p>从标题看 <code class=\"language-text\">apk 包体积有显著减少</code>（这个太有吸引力了），通过下面的描述，大致意思是不再保留 R 的 keep 规则，也就是 app 中不再包括 R 文件？（要不怎么减少包体积的）</p>\n<p>在分析这个结果之前先介绍下 apk 中，R 文件冗余的问题；</p>\n<h3>R 文件冗余问题</h3>\n<p>android 从 ADT 14 开始为了解决多个 library 中 R 文件中 id 冲突，所以将 Library 中的 R 的改成 static 的非常量属性。</p>\n<p>在 apk 打包的过程中，module 中的 R 文件采用对依赖库的R进行累计叠加的方式生成。如果我们的 app 架构如下：</p>\n<p><img src=\"https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/9543238292/c17a/0a39/2dfb/2aaa68ec576e7247a840e965ae31e2ff.jpg\" alt=\"image\"></p>\n<p>编译打包时每个模块生成的 R 文件如下：</p>\n<ol>\n<li>R<em>lib1 = R</em>lib1;</li>\n<li>R<em>lib2 = R</em>lib2;</li>\n<li>R<em>lib3 = R</em>lib3;</li>\n<li>R<em>biz1 = R</em>lib1 + R<em>lib2 + R</em>lib3 + R_biz1(biz1本身的R)</li>\n<li>R<em>biz2 = R</em>lib2 + R<em>lib3 + R</em>biz2(biz2本身的R)</li>\n<li>R<em>app = R</em>lib1 + R<em>lib2 + R</em>lib3 + R<em>biz1 + R</em>biz2 + R_app(app本身R)</li>\n</ol>\n<p>在最终打成 apk 时,除了 R_app（因为 app 中的 R 是常量，在 javac 阶段 R 引用就会被替换成常量，所以打 release 混淆时，app 中的 R 文件会被 shrink 掉），其余的 R 文件全部都会打进 apk 包中。这就是 apk 中 R 文件冗余的由来。而且如果项目依赖层次越多，上层的业务组件越多，将会导致 apk 中的 R 文件将急剧的膨胀。</p>\n<h3>R 文件内联（解决冗余问题）</h3>\n<p>系统导致的冗余问题，总不会难住聪明的程序员。在业内目前已经有一些R文件内联的解决方案。大致思路如下：</p>\n<blockquote>\n<p>由于 R<em>app 是包括了所有依赖的的 R，所以可以自定义一个 transform 将所有 library module 中 R 引用都改成对 R</em>app 中的属性引用，然后删除所有依赖库中的 R 文件。这样在 app 中就只有一个顶层 R 文件。(这种做法不是非常彻底，在 apk 中仍然保留了一个顶层的 R，更彻底的可以将所有代码中对 R 的引用都替换成常量，并在 apk 中删除顶层的 R )</p>\n</blockquote>\n<h2>agp 4.1.0 R 文件内联</h2>\n<p>首先我们分别用 agp 4.1.0 和 agp 3.6.0 构建 apk 进行一个对比，从最终的产物来确认下是否做了 R 文件内联这件事。\n测试工程做了一些便于分析的配置，配置如下：</p>\n<ol>\n<li>\n<p>开启 proguard</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">buildTypes {\nrelease {\n    minifyEnabled true // 打开\n    proguardFiles getDefaultProguardFile(&#39;proguard-android-optimize.txt&#39;), &#39;proguard-rules.pro&#39;\n}\n}</code></pre></div>\n</li>\n<li>\n<p>关闭混淆，仅保留压缩和优化（避免混淆打开，带来的识别问题）</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// proguard-rules.pro中配置\n-dontobfuscate</code></pre></div>\n<p>构建 release 包。\n先看下 agp 3.6.0 生成的 apk：</p>\n</li>\n</ol>\n<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/9543995348/a4cd/ef4a/4d3c/1d78b4f6951622a8ce9997420963ebe3.jpg\" alt=\"image\"></p>\n<p>从图中可以看到 <code class=\"language-text\">bizlib</code> module 中会有 R 文件,查看 <code class=\"language-text\">SecondActivity</code> 的 byte code ，会发现内部有对 R 文件的引用。</p>\n<p>接着再来看 agp 4.1.0 生成的 apk：</p>\n<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/9543989375/4f8a/6d85/ad31/df20e4b82c86d071102cdf3a3b01099b.jpg\" alt=\"image\"></p>\n<p>可以看到，<code class=\"language-text\">bizlib</code> module 中已经没有 R 文件，并且查看 <code class=\"language-text\">SecondActivity</code> 的 byte code ，会发现内部的引用已经变成了一个常量。</p>\n<p>由此可以确定，agp 4.1.0 是做了对 R 文件的内联，并且做的很彻底，不仅删除了冗余的 R 文件，并且还把所有对 R 文件的引用都改成了常量。</p>\n<h3>具体分析</h3>\n<p>现在我们来具体分析下 agp 4.1.0 是如何做到 R 内联的，首先我们大致分析下，要对 R 做内联，基本可以猜想到是在 class 到 dex 这个过程中做的。确定了大致阶段，那接下看能不能从构建产物来缩小相应的范围，最好能精确到具体的 task。（题外话：分析编译相关问题一般四板斧：1. 先从 app 的构建产物里面分析相应的结果；2.涉及到有依赖关系分析的可以将所有 task 的输入输出全部打印出来；3. 1、2满足不了时，会考虑去看相应的源码；4. 最后的大招就是调试编译过程；）</p>\n<p>首先我们看下构建产物里面的 dex，如下图：</p>\n<p><img src=\"https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/9552333734/d35f/fcef/b005/9808a1c930a8043bb143e9142b6b81ce.jpg\" alt=\"image\"></p>\n<p>接下来在 app module 中增加所有 task 输入输出打印的 gradle 脚本来辅助分析，相关脚本如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"groovy\"><pre class=\"language-groovy\"><code class=\"language-groovy\">gradle<span class=\"token operator\">.</span>taskGraph<span class=\"token operator\">.</span>afterTask <span class=\"token punctuation\">{</span> task <span class=\"token operator\">-></span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string gstring\">\"---- task name:\"</span> <span class=\"token operator\">+</span> task<span class=\"token operator\">.</span>name<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string gstring\">\"-------- inputs:\"</span><span class=\"token punctuation\">)</span>\n        task<span class=\"token operator\">.</span>inputs<span class=\"token operator\">.</span>files<span class=\"token operator\">.</span>each <span class=\"token punctuation\">{</span> it <span class=\"token operator\">-></span>\n            <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>it<span class=\"token operator\">.</span>absolutePath<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string gstring\">\"-------- outputs:\"</span><span class=\"token punctuation\">)</span>\n        task<span class=\"token operator\">.</span>outputs<span class=\"token operator\">.</span>files<span class=\"token operator\">.</span>each <span class=\"token punctuation\">{</span> it <span class=\"token operator\">-></span>\n            <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>it<span class=\"token operator\">.</span>absolutePath<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>Exception e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">minifyReleaseWithR8</code> 相应的输入输出如下：</p>\n<p><img src=\"https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/9552381148/cc46/1b51/4fa9/744e8880cf08288d0d69cf38faea9a87.jpg\" alt=\"image\"></p>\n<p>从图中可以看出，输入有整个 app 的 R 文件的集合（R.jar）,所以基本明确 R 的内联就是在 <code class=\"language-text\">minifyReleaseWithR8</code> task 中处理的。</p>\n<p>接下来我们就具体分析下这个 task。\n具体的逻辑在 <code class=\"language-text\">R8Task.kt</code> 里面.</p>\n<p>创建 <code class=\"language-text\">minifyReleaseWithR8</code> task 代码如下:</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> <span class=\"token function\">CreationAction</span><span class=\"token punctuation\">(</span>\n        creationConfig<span class=\"token operator\">:</span> BaseCreationConfig<span class=\"token punctuation\">,</span>\n        isTestApplication<span class=\"token operator\">:</span> Boolean <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n    <span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> ProguardConfigurableTask<span class=\"token punctuation\">.</span>CreationAction<span class=\"token operator\">&lt;</span>R8Task<span class=\"token punctuation\">,</span> BaseCreationConfig<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>creationConfig<span class=\"token punctuation\">,</span> isTestApplication<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">override</span> <span class=\"token keyword\">val</span> type <span class=\"token operator\">=</span> R8Task<span class=\"token operator\">::</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span>java\n        <span class=\"token comment\">// 创建 minifyReleaseWithR8 task</span>\n        <span class=\"token keyword\">override</span> <span class=\"token keyword\">val</span> name <span class=\"token operator\">=</span>  <span class=\"token function\">computeTaskName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"minify\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"WithR8\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token operator\">..</span><span class=\"token operator\">..</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>task 执行过程如下（由于代码过多，下面仅贴出部分关键节点）：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">    <span class=\"token comment\">// 1. 第一步，task 具体执行</span>\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">doTaskAction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">..</span><span class=\"token operator\">..</span><span class=\"token operator\">..</span>\n        <span class=\"token comment\">// 执行 shrink 操作</span>\n        <span class=\"token function\">shrink</span><span class=\"token punctuation\">(</span>\n            bootClasspath <span class=\"token operator\">=</span> bootClasspath<span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            minSdkVersion <span class=\"token operator\">=</span> minSdkVersion<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            <span class=\"token operator\">..</span><span class=\"token operator\">..</span><span class=\"token operator\">..</span>\n        <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token comment\">// 2. 第二步，调用 shrink 方法，主要做一些输入参数和配置项目的准备</span>\n    <span class=\"token keyword\">companion</span> <span class=\"token keyword\">object</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">fun</span> <span class=\"token function\">shrink</span><span class=\"token punctuation\">(</span>\n            bootClasspath<span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>File<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n            <span class=\"token operator\">..</span><span class=\"token operator\">..</span><span class=\"token operator\">..</span>\n        <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token operator\">..</span><span class=\"token operator\">..</span><span class=\"token operator\">..</span>\n            <span class=\"token comment\">// 调用 r8Tool.kt 中的顶层方法，runR8</span>\n            <span class=\"token function\">runR8</span><span class=\"token punctuation\">(</span>\n                <span class=\"token function\">filterMissingFiles</span><span class=\"token punctuation\">(</span>classes<span class=\"token punctuation\">,</span> logger<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                output<span class=\"token punctuation\">.</span><span class=\"token function\">toPath</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                <span class=\"token operator\">..</span><span class=\"token operator\">..</span><span class=\"token operator\">..</span>\n            <span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 3. 第三步,调用 R8 工具类，执行混淆、优化、脱糖、class to dex 等一系列操作</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">runR8</span><span class=\"token punctuation\">(</span>\n        inputClasses<span class=\"token operator\">:</span> Collection<span class=\"token operator\">&lt;</span>Path<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n        <span class=\"token operator\">..</span><span class=\"token operator\">..</span><span class=\"token operator\">..</span>\n    <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token operator\">..</span><span class=\"token operator\">..</span><span class=\"token operator\">..</span>\n        <span class=\"token function\">ClassFileProviderFactory</span><span class=\"token punctuation\">(</span>libraries<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">use</span> <span class=\"token punctuation\">{</span> libraryClasses <span class=\"token operator\">-></span>\n            <span class=\"token function\">ClassFileProviderFactory</span><span class=\"token punctuation\">(</span>classpath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">use</span> <span class=\"token punctuation\">{</span> classpathClasses <span class=\"token operator\">-></span>\n                r8CommandBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">addLibraryResourceProvider</span><span class=\"token punctuation\">(</span>libraryClasses<span class=\"token punctuation\">.</span>orderedProvider<span class=\"token punctuation\">)</span>\n                r8CommandBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">addClasspathResourceProvider</span><span class=\"token punctuation\">(</span>classpathClasses<span class=\"token punctuation\">.</span>orderedProvider<span class=\"token punctuation\">)</span>\n                <span class=\"token comment\">// 调用 R8 工具类中的run方法</span>\n                R8<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span>r8CommandBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<p>至此可以知道实际上 agp 4.1.0 中是通过 R8 来做到 R 文件的内联的。那 R8 是如果做到的呢？这里简要描述下，不再做具体代码的分析：</p>\n<blockquote>\n<p>R8 从能力上是包括了 Proguard 和 D8（java脱糖、dx、multidex），也就是从 class 到 dex 的过程，并在这个过程中做了脱糖、Proguard 及 multidex 等事情。在 R8 对代码做 shrink 和 optimize 时会将代码中对常量的引用替换成常量值。这样代码中将不会有对 R 文件的引用，这样在 shrink 时就会将 R 文件删除。\n当然要达到这个效果 agp 在 4.1.0 版本里面对默认的 keep 规则也要做一些调整，4.1.0 里面删除了<a href=\"https://issuetracker.google.com/issues/142449264\">默认对 R 的 keep 规则</a>，相应的规则如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-keepclassmembers class **.R$* {\n   public static &lt;fields&gt;;\n}</code></pre></div>\n</blockquote>\n<h2>总结</h2>\n<ol>\n<li>从 agp 对 R 文件的处理历史来看，android  编译团队一直在对R文件的生成过程不断做优化，并在 agp 4.1.0 版本中彻底解决了 R 文件冗余的问题。</li>\n<li>\n<p>编译相关问题分析思路：</p>\n<ol>\n<li>先从 app 的构建产物里面分析相应的结果；</li>\n<li>涉及到有依赖关系分析的可以将所有 task 的输入输出全部打印出来；</li>\n<li>1、2满足不了时，会考虑去看相应的源码；</li>\n<li>最后的大招就是调试编译过程；</li>\n</ol>\n</li>\n<li>从云音乐 app 这次 agp 升级的效果来看，app 的体积降低了接近 7M，编译速度也有很大的提升，特别是 release 速度快了 10 分钟+（task 合并），整体收益还是比较可观的。</li>\n</ol>\n<p>文章中使用的<a href=\"https://github.com/sunday1937/AgpTest2\">测试工程</a>；</p>\n<h2>参考资料</h2>\n<ol>\n<li><a href=\"https://developer.android.com/studio/build/shrink-code\">Shrink, obfuscate, and optimize your app</a></li>\n<li><a href=\"https://r8.googlesource.com/r8/\">r8</a></li>\n<li><a href=\"https://developer.android.com/studio/releases/gradle-plugin#4-1-0\">Android Gradle plugin release notes</a></li>\n</ol>\n<blockquote>\n<p>本文发布自 <a href=\"https://github.com/x-orpheus\">网易云音乐大前端团队</a>，文章未经授权禁止任何形式的转载。我们常年招收前端、iOS、Android，如果你准备换工作，又恰好喜欢云音乐，那就加入我们 grp.music-fe(at)corp.netease.com！</p>\n</blockquote>","frontmatter":{"title":"android agp 对 R 文件内联支持","date":"2021-07-20","description":"本文介绍android agp 4.1.0 如何支持 R 文件内联以及 R 文件的一些历史问题。"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/android-agp/","previous":{"fields":{"slug":"/svg/"},"frontmatter":{"title":"SVG基础及其动画应用浅析"}},"next":{"fields":{"slug":"/car-app/"},"frontmatter":{"title":"如何把应用搬上车"}}}}}